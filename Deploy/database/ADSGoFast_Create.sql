/*
Deployment script for ADSGoFast

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "ADSGoFast"
:setvar DefaultFilePrefix "ADSGoFast"
:setvar DefaultDataPath ""
:setvar DefaultLogPath ""

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
/* Please run the below section of statements against 'master' database. */
PRINT N'Creating $(DatabaseName)...'
GO
CREATE DATABASE [$(DatabaseName)] COLLATE SQL_Latin1_General_CP1_CI_AS
GO
DECLARE  @job_state INT = 0;
DECLARE  @index INT = 0;
DECLARE @EscapedDBNameLiteral sysname = N'$(DatabaseName)'
WAITFOR DELAY '00:00:30';
WHILE (@index < 60) 
BEGIN
	SET @job_state = ISNULL( (SELECT SUM (result)  FROM (
		SELECT TOP 1 [state] AS result
		FROM sys.dm_operation_status WHERE resource_type = 0 
		AND operation = 'CREATE DATABASE' AND major_resource_id = @EscapedDBNameLiteral AND [state] = 2
		ORDER BY start_time DESC
		) r), -1);

	SET @index = @index + 1;

	IF @job_state = 0 /* pending */ OR @job_state = 1 /* in progress */ OR @job_state = -1 /* job not found */ OR (SELECT [state] FROM sys.databases WHERE name = @EscapedDBNameLiteral) <> 0
		WAITFOR DELAY '00:00:30';
	ELSE 
    	BREAK;
END
GO
/* Please run the below section of statements against the database name that the above [$(DatabaseName)] variable is assigned to. */
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                NUMERIC_ROUNDABORT OFF,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_CLOSE_ON_COMMIT OFF,
                AUTO_CREATE_STATISTICS ON,
                AUTO_SHRINK OFF,
                AUTO_UPDATE_STATISTICS ON,
                RECURSIVE_TRIGGERS OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ALLOW_SNAPSHOT_ISOLATION OFF;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_UPDATE_STATISTICS_ASYNC OFF,
                DATE_CORRELATION_OPTIMIZATION OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CREATE_STATISTICS ON(INCREMENTAL = OFF) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE (QUERY_CAPTURE_MODE = ALL, DATA_FLUSH_INTERVAL_SECONDS = 900, INTERVAL_LENGTH_MINUTES = 60, MAX_PLANS_PER_QUERY = 200, CLEANUP_POLICY = (STALE_QUERY_THRESHOLD_DAYS = 367), MAX_STORAGE_SIZE_MB = 100) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE = OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE SCOPED CONFIGURATION SET MAXDOP = 0;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET MAXDOP = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET LEGACY_CARDINALITY_ESTIMATION = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET LEGACY_CARDINALITY_ESTIMATION = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET PARAMETER_SNIFFING = ON;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET PARAMETER_SNIFFING = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET QUERY_OPTIMIZER_HOTFIXES = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET QUERY_OPTIMIZER_HOTFIXES = PRIMARY;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET TEMPORAL_HISTORY_RETENTION ON 
            WITH ROLLBACK IMMEDIATE;
    END


GO
PRINT N'Creating [Pbi]...';


GO
CREATE SCHEMA [Pbi]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [WebApp]...';


GO
CREATE SCHEMA [WebApp]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [dbo].[ADFPipelineRun]...';


GO
CREATE TABLE [dbo].[ADFPipelineRun] (
    [TaskInstanceId]           BIGINT             NOT NULL,
    [ExecutionUid]             UNIQUEIDENTIFIER   NOT NULL,
    [DatafactoryId]            BIGINT             NOT NULL,
    [PipelineRunUid]           UNIQUEIDENTIFIER   NOT NULL,
    [Start]                    DATETIMEOFFSET (7) NULL,
    [End]                      DATETIMEOFFSET (7) NULL,
    [PipelineName]             VARCHAR (255)      NULL,
    [PipelineRunStatus]        VARCHAR (100)      NOT NULL,
    [MaxPipelineTimeGenerated] DATETIMEOFFSET (7) NOT NULL,
    CONSTRAINT [PK_ADFPipelineRun] PRIMARY KEY CLUSTERED ([TaskInstanceId] ASC, [ExecutionUid] ASC, [DatafactoryId] ASC, [PipelineRunUid] ASC)
);


GO
PRINT N'Creating [dbo].[FrameworkTaskRunner]...';


GO
CREATE TABLE [dbo].[FrameworkTaskRunner] (
    [TaskRunnerId]               INT                NOT NULL,
    [TaskRunnerName]             VARCHAR (255)      NULL,
    [ActiveYN]                   BIT                NULL,
    [Status]                     VARCHAR (25)       NULL,
    [MaxConcurrentTasks]         INT                NULL,
    [LastExecutionStartDateTime] DATETIMEOFFSET (7) NULL,
    [LastExecutionEndDateTime]   DATETIMEOFFSET (7) NULL,
    PRIMARY KEY CLUSTERED ([TaskRunnerId] ASC)
);


GO
PRINT N'Creating [dbo].[TaskMasterWaterMark]...';


GO
CREATE TABLE [dbo].[TaskMasterWaterMark] (
    [TaskMasterId]                  BIGINT             NOT NULL,
    [TaskMasterWaterMarkColumn]     NVARCHAR (200)     NOT NULL,
    [TaskMasterWaterMarkColumnType] NVARCHAR (50)      NOT NULL,
    [TaskMasterWaterMark_DateTime]  DATETIME           NULL,
    [TaskMasterWaterMark_BigInt]    BIGINT             NULL,
    [TaskWaterMarkJSON]             NVARCHAR (4000)    NULL,
    [ActiveYN]                      BIT                NOT NULL,
    [UpdatedOn]                     DATETIMEOFFSET (7) NOT NULL,
    PRIMARY KEY CLUSTERED ([TaskMasterId] ASC)
);


GO
PRINT N'Creating [dbo].[DataFactory]...';


GO
CREATE TABLE [dbo].[DataFactory] (
    [Id]                      BIGINT           IDENTITY (1, 1) NOT NULL,
    [Name]                    VARCHAR (255)    NULL,
    [ResourceGroup]           VARCHAR (255)    NULL,
    [SubscriptionUid]         UNIQUEIDENTIFIER NULL,
    [DefaultKeyVaultURL]      VARCHAR (255)    NULL,
    [LogAnalyticsWorkspaceId] UNIQUEIDENTIFIER NULL
);


GO
PRINT N'Creating [dbo].[TaskGroupDependency]...';


GO
CREATE TABLE [dbo].[TaskGroupDependency] (
    [AncestorTaskGroupId]   BIGINT        NOT NULL,
    [DescendantTaskGroupId] BIGINT        NOT NULL,
    [DependencyType]        VARCHAR (200) NOT NULL,
    CONSTRAINT [PK_TaskGroupDependency] PRIMARY KEY CLUSTERED ([AncestorTaskGroupId] ASC, [DescendantTaskGroupId] ASC)
);


GO
PRINT N'Creating [dbo].[TaskMasterDependency]...';


GO
CREATE TABLE [dbo].[TaskMasterDependency] (
    [AncestorTaskMasterId]   BIGINT NOT NULL,
    [DescendantTaskMasterId] BIGINT NOT NULL,
    CONSTRAINT [PK_TaskMasterDependency] PRIMARY KEY CLUSTERED ([AncestorTaskMasterId] ASC, [DescendantTaskMasterId] ASC)
);


GO
PRINT N'Creating [dbo].[TaskTypeMapping]...';


GO
CREATE TABLE [dbo].[TaskTypeMapping] (
    [TaskTypeMappingId]      INT            IDENTITY (1, 1) NOT NULL,
    [TaskTypeId]             INT            NOT NULL,
    [MappingType]            NVARCHAR (128) NOT NULL,
    [MappingName]            NVARCHAR (128) NOT NULL,
    [SourceSystemType]       NVARCHAR (128) NOT NULL,
    [SourceType]             NVARCHAR (128) NOT NULL,
    [TargetSystemType]       NVARCHAR (128) NOT NULL,
    [TargetType]             NVARCHAR (128) NOT NULL,
    [TaskDatafactoryIR]      NVARCHAR (128) NOT NULL,
    [TaskTypeJson]           NVARCHAR (MAX) NULL,
    [ActiveYN]               BIT            NOT NULL,
    [TaskMasterJsonSchema]   VARCHAR (MAX)  NULL,
    [TaskInstanceJsonSchema] VARCHAR (MAX)  NULL,
    CONSTRAINT [PK__TaskType__C274052A4E989D69] PRIMARY KEY CLUSTERED ([TaskTypeMappingId] ASC)
);


GO
PRINT N'Creating [dbo].[TaskType]...';


GO
CREATE TABLE [dbo].[TaskType] (
    [TaskTypeId]        INT            IDENTITY (1, 1) NOT NULL,
    [TaskTypeName]      NVARCHAR (128) NOT NULL,
    [TaskExecutionType] NVARCHAR (5)   NOT NULL,
    [TaskTypeJson]      NVARCHAR (MAX) NULL,
    [ActiveYN]          BIT            NOT NULL,
    CONSTRAINT [PK__TaskType__66B23E33F65B5D8C] PRIMARY KEY CLUSTERED ([TaskTypeId] ASC)
);


GO
PRINT N'Creating [dbo].[ScheduleInstance]...';


GO
CREATE TABLE [dbo].[ScheduleInstance] (
    [ScheduleInstanceId]      BIGINT             IDENTITY (1, 1) NOT NULL,
    [ScheduleMasterId]        BIGINT             NULL,
    [ScheduledDateUtc]        DATETIME           NULL,
    [ScheduledDateTimeOffset] DATETIMEOFFSET (7) NULL,
    [ActiveYN]                BIT                NULL,
    PRIMARY KEY CLUSTERED ([ScheduleInstanceId] ASC)
);


GO
PRINT N'Creating [dbo].[TaskInstanceExecution]...';


GO
CREATE TABLE [dbo].[TaskInstanceExecution] (
    [ExecutionUid]               UNIQUEIDENTIFIER   NOT NULL,
    [TaskInstanceId]             BIGINT             NOT NULL,
    [DatafactorySubscriptionUid] UNIQUEIDENTIFIER   NULL,
    [DatafactoryResourceGroup]   VARCHAR (255)      NULL,
    [DatafactoryName]            VARCHAR (255)      NULL,
    [PipelineName]               VARCHAR (200)      NULL,
    [AdfRunUid]                  UNIQUEIDENTIFIER   NULL,
    [StartDateTime]              DATETIMEOFFSET (7) NULL,
    [EndDateTime]                DATETIMEOFFSET (7) NULL,
    [Status]                     VARCHAR (25)       NOT NULL,
    [Comment]                    VARCHAR (255)      NULL,
    CONSTRAINT [PK_TaskInstanceExecution] PRIMARY KEY CLUSTERED ([ExecutionUid] ASC, [TaskInstanceId] ASC)
);


GO
PRINT N'Creating [dbo].[TaskInstance]...';


GO
CREATE TABLE [dbo].[TaskInstance] (
    [TaskInstanceId]       BIGINT             IDENTITY (1, 1) NOT NULL,
    [TaskMasterId]         BIGINT             NOT NULL,
    [ScheduleInstanceId]   BIGINT             NOT NULL,
    [ExecutionUid]         UNIQUEIDENTIFIER   NOT NULL,
    [ADFPipeline]          NVARCHAR (128)     NOT NULL,
    [TaskInstanceJson]     NVARCHAR (MAX)     NULL,
    [LastExecutionStatus]  VARCHAR (25)       NULL,
    [LastExecutionUid]     UNIQUEIDENTIFIER   NULL,
    [LastExecutionComment] VARCHAR (255)      NULL,
    [NumberOfRetries]      INT                NOT NULL,
    [ActiveYN]             BIT                NULL,
    [CreatedOn]            DATETIMEOFFSET (7) NULL,
    [UpdatedOn]            DATETIMEOFFSET (7) NULL,
    [TaskRunnerId]         INT                NULL,
    CONSTRAINT [PK__TaskInst__548FCBDED6C62FEB] PRIMARY KEY CLUSTERED ([TaskInstanceId] ASC)
);


GO
PRINT N'Creating [dbo].[TaskInstance].[nci_wi_TaskInstance_B5B588158C01F320F9EC80B7B88A2418]...';


GO
CREATE NONCLUSTERED INDEX [nci_wi_TaskInstance_B5B588158C01F320F9EC80B7B88A2418]
    ON [dbo].[TaskInstance]([TaskMasterId] ASC, [LastExecutionStatus] ASC);


GO
PRINT N'Creating [dbo].[TaskInstance].[nci_wi_TaskInstance_A8DC1B064B0B11088227C31A5B65513B]...';


GO
CREATE NONCLUSTERED INDEX [nci_wi_TaskInstance_A8DC1B064B0B11088227C31A5B65513B]
    ON [dbo].[TaskInstance]([LastExecutionStatus] ASC)
    INCLUDE([TaskMasterId], [TaskRunnerId]);


GO
PRINT N'Creating [dbo].[TaskInstance].[nci_wi_TaskInstance_67CB7E97C34F783EB26BEBAEACEC0D7E]...';


GO
CREATE NONCLUSTERED INDEX [nci_wi_TaskInstance_67CB7E97C34F783EB26BEBAEACEC0D7E]
    ON [dbo].[TaskInstance]([LastExecutionStatus] ASC)
    INCLUDE([ScheduleInstanceId], [TaskMasterId]);


GO
PRINT N'Creating [dbo].[TaskInstance].[nci_wi_TaskInstance_0EEF2CCAE417C39EAA3C6FFC345D5787]...';


GO
CREATE NONCLUSTERED INDEX [nci_wi_TaskInstance_0EEF2CCAE417C39EAA3C6FFC345D5787]
    ON [dbo].[TaskInstance]([ActiveYN] ASC, [TaskRunnerId] ASC, [LastExecutionStatus] ASC)
    INCLUDE([ScheduleInstanceId], [TaskMasterId]);


GO
PRINT N'Creating [dbo].[TaskInstance].[ix_taskinstance_taskmasterid]...';


GO
CREATE NONCLUSTERED INDEX [ix_taskinstance_taskmasterid]
    ON [dbo].[TaskInstance]([TaskMasterId] ASC);


GO
PRINT N'Creating [dbo].[ScheduleMaster]...';


GO
CREATE TABLE [dbo].[ScheduleMaster] (
    [ScheduleMasterId]       BIGINT         IDENTITY (1, 1) NOT NULL,
    [ScheduleCronExpression] NVARCHAR (200) NOT NULL,
    [ScheduleDesciption]     VARCHAR (200)  NOT NULL,
    [ActiveYN]               BIT            NULL,
    PRIMARY KEY CLUSTERED ([ScheduleMasterId] ASC)
);


GO
PRINT N'Creating [dbo].[TaskMaster]...';


GO
CREATE TABLE [dbo].[TaskMaster] (
    [TaskMasterId]                 BIGINT          IDENTITY (1, 1) NOT NULL,
    [TaskMasterName]               NVARCHAR (200)  NOT NULL,
    [TaskTypeId]                   INT             NOT NULL,
    [TaskGroupId]                  BIGINT          NOT NULL,
    [ScheduleMasterId]             BIGINT          NOT NULL,
    [SourceSystemId]               BIGINT          NOT NULL,
    [TargetSystemId]               BIGINT          NOT NULL,
    [DegreeOfCopyParallelism]      INT             NOT NULL,
    [AllowMultipleActiveInstances] BIT             NOT NULL,
    [TaskDatafactoryIR]            NVARCHAR (20)   NOT NULL,
    [TaskMasterJSON]               NVARCHAR (4000) NULL,
    [ActiveYN]                     BIT             NOT NULL,
    [DependencyChainTag]           VARCHAR (50)    NULL,
    [DataFactoryId]                BIGINT          NOT NULL,
    CONSTRAINT [PK__TaskMast__EB7286F6C9A58EA9] PRIMARY KEY CLUSTERED ([TaskMasterId] ASC)
);


GO
PRINT N'Creating [dbo].[TaskMaster].[nci_wi_TaskMaster_D7BDAE69478BDFB67BBA9E4F9BB3DD7F]...';


GO
CREATE NONCLUSTERED INDEX [nci_wi_TaskMaster_D7BDAE69478BDFB67BBA9E4F9BB3DD7F]
    ON [dbo].[TaskMaster]([TaskGroupId] ASC, [DependencyChainTag] ASC)
    INCLUDE([SourceSystemId], [TargetSystemId]);


GO
PRINT N'Creating [dbo].[SourceAndTargetSystems]...';


GO
CREATE TABLE [dbo].[SourceAndTargetSystems] (
    [SystemId]              BIGINT          IDENTITY (1, 1) NOT NULL,
    [SystemName]            NVARCHAR (128)  NOT NULL,
    [SystemType]            NVARCHAR (128)  NOT NULL,
    [SystemDescription]     NVARCHAR (128)  NOT NULL,
    [SystemServer]          NVARCHAR (128)  NOT NULL,
    [SystemAuthType]        NVARCHAR (20)   NOT NULL,
    [SystemUserName]        NVARCHAR (128)  NULL,
    [SystemSecretName]      NVARCHAR (128)  NULL,
    [SystemKeyVaultBaseUrl] NVARCHAR (500)  NULL,
    [SystemJSON]            NVARCHAR (4000) NULL,
    [ActiveYN]              BIT             NOT NULL,
    PRIMARY KEY CLUSTERED ([SystemId] ASC)
);


GO
PRINT N'Creating [dbo].[TaskGroup]...';


GO
CREATE TABLE [dbo].[TaskGroup] (
    [TaskGroupId]          BIGINT          IDENTITY (1, 1) NOT NULL,
    [SubjectAreaId]        INT             NOT NULL,
    [TaskGroupName]        NVARCHAR (200)  NOT NULL,
    [TaskGroupPriority]    INT             NOT NULL,
    [TaskGroupConcurrency] INT             NOT NULL,
    [TaskGroupJSON]        NVARCHAR (4000) NULL,
    [MaximumTaskRetries]   INT             NOT NULL,
    [ActiveYN]             BIT             NULL,
    CONSTRAINT [PK__TaskGrou__1EAD70161628472C] PRIMARY KEY CLUSTERED ([TaskGroupId] ASC)
);


GO
PRINT N'Creating [dbo].[Execution]...';


GO
CREATE TABLE [dbo].[Execution] (
    [ExecutionUid]  UNIQUEIDENTIFIER   NOT NULL,
    [StartDateTime] DATETIMEOFFSET (7) NULL,
    [EndDateTime]   DATETIMEOFFSET (7) NULL,
    PRIMARY KEY CLUSTERED ([ExecutionUid] ASC)
);


GO
PRINT N'Creating [dbo].[SubjectAreaHistory]...';


GO
CREATE TABLE [dbo].[SubjectAreaHistory] (
    [SubjectAreaId]       INT           NOT NULL,
    [SubjectAreaName]     VARCHAR (255) NULL,
    [ActiveYN]            BIT           NULL,
    [SubjectAreaFormId]   INT           NULL,
    [DefaultTargetSchema] VARCHAR (255) NULL,
    [UpdatedBy]           VARCHAR (255) NULL,
    [ValidFrom]           DATETIME2 (0) NOT NULL,
    [ValidTo]             DATETIME2 (0) NOT NULL
);


GO
PRINT N'Creating [dbo].[SubjectAreaHistory].[ix_SubjectAreaHistory]...';


GO
CREATE CLUSTERED INDEX [ix_SubjectAreaHistory]
    ON [dbo].[SubjectAreaHistory]([ValidTo] ASC, [ValidFrom] ASC) WITH (DATA_COMPRESSION = PAGE);


GO
PRINT N'Creating [dbo].[SubjectAreaRoleMapHistory]...';


GO
CREATE TABLE [dbo].[SubjectAreaRoleMapHistory] (
    [SubjectAreaId]       INT              NOT NULL,
    [AadGroupUid]         UNIQUEIDENTIFIER NOT NULL,
    [ApplicationRoleName] VARCHAR (255)    NOT NULL,
    [ExpiryDate]          DATE             NOT NULL,
    [ActiveYN]            BIT              NOT NULL,
    [UpdatedBy]           VARCHAR (255)    NULL,
    [ValidFrom]           DATETIME2 (0)    NOT NULL,
    [ValidTo]             DATETIME2 (0)    NOT NULL
);


GO
PRINT N'Creating [dbo].[SubjectAreaRoleMapHistory].[ix_SubjectAreaRoleMapHistory]...';


GO
CREATE CLUSTERED INDEX [ix_SubjectAreaRoleMapHistory]
    ON [dbo].[SubjectAreaRoleMapHistory]([ValidTo] ASC, [ValidFrom] ASC) WITH (DATA_COMPRESSION = PAGE);


GO
PRINT N'Creating [dbo].[SubjectAreaSystemMapHistory]...';


GO
CREATE TABLE [dbo].[SubjectAreaSystemMapHistory] (
    [SubjectAreaId]       INT           NOT NULL,
    [SystemId]            BIGINT        NOT NULL,
    [MappingType]         TINYINT       NOT NULL,
    [AllowedSchemas]      VARCHAR (MAX) NOT NULL,
    [ActiveYN]            BIT           NULL,
    [SubjectAreaFormId]   INT           NULL,
    [DefaultTargetSchema] VARCHAR (255) NULL,
    [UpdatedBy]           VARCHAR (255) NULL,
    [ValidFrom]           DATETIME2 (0) NOT NULL,
    [ValidTo]             DATETIME2 (0) NOT NULL
);


GO
PRINT N'Creating [dbo].[SubjectAreaSystemMapHistory].[ix_SubjectAreaSystemMapHistory]...';


GO
CREATE CLUSTERED INDEX [ix_SubjectAreaSystemMapHistory]
    ON [dbo].[SubjectAreaSystemMapHistory]([ValidTo] ASC, [ValidFrom] ASC) WITH (DATA_COMPRESSION = PAGE);


GO
PRINT N'Creating [dbo].[AzureStorageChangeFeed]...';


GO
CREATE TABLE [dbo].[AzureStorageChangeFeed] (
    [EventTime]                                DATETIMEOFFSET (7) NULL,
    [EventType]                                VARCHAR (MAX)      NULL,
    [Subject]                                  VARCHAR (MAX)      NULL,
    [Topic]                                    VARCHAR (MAX)      NULL,
    [EventData.BlobOperationName]              VARCHAR (MAX)      NULL,
    [EventData.BlobType]                       VARCHAR (MAX)      NULL,
    [Pkey1ebebb3a-d7af-4315-93c8-a438fe7a36ff] BIGINT             IDENTITY (1, 1) NOT NULL,
    PRIMARY KEY CLUSTERED ([Pkey1ebebb3a-d7af-4315-93c8-a438fe7a36ff] ASC)
);


GO
PRINT N'Creating [dbo].[AzureStorageChangeFeedCursor]...';


GO
CREATE TABLE [dbo].[AzureStorageChangeFeedCursor] (
    [SourceSystemId]   BIGINT        NOT NULL,
    [ChangeFeedCursor] VARCHAR (MAX) NULL,
    PRIMARY KEY CLUSTERED ([SourceSystemId] ASC)
);


GO
PRINT N'Creating [dbo].[ADFActivityErrors]...';


GO
CREATE TABLE [dbo].[ADFActivityErrors] (
    [DatafactoryId]               BIGINT           NULL,
    [TenantId]                    VARCHAR (MAX)    NULL,
    [SourceSystem]                VARCHAR (MAX)    NULL,
    [TimeGenerated]               DATETIME         NULL,
    [ResourceId]                  VARCHAR (MAX)    NULL,
    [OperationName]               VARCHAR (MAX)    NULL,
    [Category]                    VARCHAR (MAX)    NULL,
    [CorrelationId]               UNIQUEIDENTIFIER NOT NULL,
    [Level]                       VARCHAR (MAX)    NULL,
    [Location]                    VARCHAR (MAX)    NULL,
    [Tags]                        VARCHAR (MAX)    NULL,
    [Status]                      VARCHAR (MAX)    NULL,
    [UserProperties]              VARCHAR (MAX)    NULL,
    [Annotations]                 VARCHAR (MAX)    NULL,
    [EventMessage]                VARCHAR (MAX)    NULL,
    [Start]                       DATETIME         NULL,
    [ActivityName]                VARCHAR (MAX)    NULL,
    [ActivityRunId]               VARCHAR (MAX)    NULL,
    [PipelineRunId]               UNIQUEIDENTIFIER NULL,
    [EffectiveIntegrationRuntime] VARCHAR (MAX)    NULL,
    [ActivityType]                VARCHAR (MAX)    NULL,
    [ActivityIterationCount]      INT              NULL,
    [LinkedServiceName]           VARCHAR (MAX)    NULL,
    [End]                         DATETIME         NULL,
    [FailureType]                 VARCHAR (MAX)    NULL,
    [PipelineName]                VARCHAR (MAX)    NULL,
    [Input]                       VARCHAR (MAX)    NULL,
    [Output]                      VARCHAR (MAX)    NULL,
    [ErrorCode]                   INT              NULL,
    [ErrorMessage]                VARCHAR (MAX)    NULL,
    [Error]                       VARCHAR (MAX)    NULL,
    [Type]                        VARCHAR (MAX)    NULL
);


GO
PRINT N'Creating [dbo].[ADFActivityErrors].[IX_ADFActivityErrors]...';


GO
CREATE CLUSTERED INDEX [IX_ADFActivityErrors]
    ON [dbo].[ADFActivityErrors]([TimeGenerated] ASC);


GO
PRINT N'Creating [dbo].[ActivityLevelLogs]...';


GO
CREATE TABLE [dbo].[ActivityLevelLogs] (
    [timestamp]         DATETIME         NULL,
    [operation_Id]      VARCHAR (MAX)    NULL,
    [operation_Name]    VARCHAR (MAX)    NULL,
    [severityLevel]     INT              NULL,
    [ExecutionUid]      UNIQUEIDENTIFIER NULL,
    [TaskInstanceId]    INT              NULL,
    [ActivityType]      VARCHAR (MAX)    NULL,
    [LogSource]         VARCHAR (MAX)    NULL,
    [LogDateUTC]        DATETIME         NULL,
    [LogDateTimeOffset] DATETIME         NULL,
    [Status]            VARCHAR (MAX)    NULL,
    [TaskMasterId]      INT              NULL,
    [Comment]           VARCHAR (MAX)    NULL,
    [message]           VARCHAR (MAX)    NULL
);


GO
PRINT N'Creating [dbo].[ActivityLevelLogs].[IX_ActivityLevelLogs]...';


GO
CREATE CLUSTERED INDEX [IX_ActivityLevelLogs]
    ON [dbo].[ActivityLevelLogs]([timestamp] ASC);


GO
PRINT N'Creating [dbo].[ActivityLevelLogs].[IX_ActivityLevelLogs_TaskInstanceId]...';


GO
CREATE NONCLUSTERED INDEX [IX_ActivityLevelLogs_TaskInstanceId]
    ON [dbo].[ActivityLevelLogs]([TaskInstanceId] ASC);


GO
PRINT N'Creating [dbo].[SourceAndTargetSystems_JsonSchema]...';


GO
CREATE TABLE [dbo].[SourceAndTargetSystems_JsonSchema] (
    [SystemType] VARCHAR (255)  NOT NULL,
    [JsonSchema] NVARCHAR (MAX) NULL,
    PRIMARY KEY CLUSTERED ([SystemType] ASC)
);


GO
PRINT N'Creating [dbo].[AzureStorageListing]...';


GO
CREATE TABLE [dbo].[AzureStorageListing] (
    [SystemId]     BIGINT         NOT NULL,
    [PartitionKey] VARCHAR (50)   NOT NULL,
    [RowKey]       VARCHAR (50)   NOT NULL,
    [FilePath]     VARCHAR (2000) NULL,
    CONSTRAINT [PK_AzureStorageListing] PRIMARY KEY CLUSTERED ([SystemId] ASC, [PartitionKey] ASC, [RowKey] ASC)
);


GO
PRINT N'Creating [dbo].[ADFActivityRun]...';


GO
CREATE TABLE [dbo].[ADFActivityRun] (
    [PipelineRunUid]                 UNIQUEIDENTIFIER   NOT NULL,
    [DataFactoryId]                  BIGINT             NOT NULL,
    [Activities]                     BIGINT             NULL,
    [TotalCost]                      REAL               NULL,
    [CloudOrchestrationCost]         REAL               NULL,
    [SelfHostedOrchestrationCost]    REAL               NULL,
    [SelfHostedDataMovementCost]     REAL               NULL,
    [SelfHostedPipelineActivityCost] REAL               NULL,
    [CloudPipelineActivityCost]      REAL               NULL,
    [rowsCopied]                     BIGINT             NULL,
    [dataRead]                       BIGINT             NULL,
    [dataWritten]                    BIGINT             NULL,
    [TaskExecutionStatus]            VARCHAR (MAX)      NULL,
    [FailedActivities]               BIGINT             NULL,
    [Start]                          DATETIMEOFFSET (7) NULL,
    [End]                            DATETIMEOFFSET (7) NULL,
    [MaxActivityTimeGenerated]       DATETIMEOFFSET (7) NULL,
    CONSTRAINT [PK_ADFActivityRun] PRIMARY KEY CLUSTERED ([PipelineRunUid] ASC, [DataFactoryId] ASC)
);


GO
PRINT N'Creating [dbo].[ADFPipelineStats]...';


GO
CREATE TABLE [dbo].[ADFPipelineStats] (
    [TaskInstanceId]                 INT                NOT NULL,
    [ExecutionUid]                   UNIQUEIDENTIFIER   NOT NULL,
    [DataFactoryId]                  BIGINT             NOT NULL,
    [Activities]                     BIGINT             NULL,
    [TotalCost]                      REAL               NULL,
    [CloudOrchestrationCost]         REAL               NULL,
    [SelfHostedOrchestrationCost]    REAL               NULL,
    [SelfHostedDataMovementCost]     REAL               NULL,
    [SelfHostedPipelineActivityCost] REAL               NULL,
    [CloudPipelineActivityCost]      REAL               NULL,
    [rowsCopied]                     BIGINT             NULL,
    [dataRead]                       BIGINT             NULL,
    [dataWritten]                    BIGINT             NULL,
    [TaskExecutionStatus]            VARCHAR (MAX)      NULL,
    [FailedActivities]               BIGINT             NULL,
    [Start]                          DATETIMEOFFSET (7) NULL,
    [End]                            DATETIMEOFFSET (7) NULL,
    [MaxActivityTimeGenerated]       DATETIMEOFFSET (7) NULL,
    [MaxPipelineTimeGenerated]       DATETIMEOFFSET (7) NOT NULL,
    [MaxPipelineDateGenerated]       AS                 (CONVERT (DATE, [MaxPipelineTimeGenerated])) PERSISTED,
    [MaxActivityDateGenerated]       AS                 (CONVERT (DATE, [MaxActivityTimeGenerated])) PERSISTED,
    CONSTRAINT [PK_ADFPipelineStats] PRIMARY KEY CLUSTERED ([TaskInstanceId] ASC, [ExecutionUid] ASC, [DataFactoryId] ASC)
);


GO
PRINT N'Creating [dbo].[ExecutionEngine]...';


GO
CREATE TABLE [dbo].[ExecutionEngine] (
    [EngineId]                BIGINT           IDENTITY (1, 1) NOT NULL,
    [EngineName]              VARCHAR (255)    NOT NULL,
    [ResouceName]             VARCHAR (255)    NULL,
    [ResourceGroup]           VARCHAR (255)    NULL,
    [SubscriptionUid]         UNIQUEIDENTIFIER NULL,
    [DefaultKeyVaultURL]      VARCHAR (255)    NULL,
    [LogAnalyticsWorkspaceId] UNIQUEIDENTIFIER NULL,
    [EngineJson]              VARCHAR (MAX)    NOT NULL,
    CONSTRAINT [PK_ExecutionEngine] PRIMARY KEY CLUSTERED ([EngineId] ASC)
);


GO
PRINT N'Creating [dbo].[SubjectArea]...';


GO
CREATE TABLE [dbo].[SubjectArea] (
    [SubjectAreaId]       INT                                         IDENTITY (1, 1) NOT NULL,
    [SubjectAreaName]     VARCHAR (255)                               NULL,
    [ActiveYN]            BIT                                         NULL,
    [SubjectAreaFormId]   INT                                         NULL,
    [DefaultTargetSchema] VARCHAR (255)                               NULL,
    [UpdatedBy]           VARCHAR (255)                               NULL,
    [ValidFrom]           DATETIME2 (0) GENERATED ALWAYS AS ROW START NOT NULL,
    [ValidTo]             DATETIME2 (0) GENERATED ALWAYS AS ROW END   NOT NULL,
    PRIMARY KEY CLUSTERED ([SubjectAreaId] ASC),
    PERIOD FOR SYSTEM_TIME ([ValidFrom], [ValidTo])
)
WITH (SYSTEM_VERSIONING = ON (HISTORY_TABLE=[dbo].[SubjectAreaHistory], DATA_CONSISTENCY_CHECK=ON));


GO
PRINT N'Creating [dbo].[SubjectAreaFormHistory]...';


GO
CREATE TABLE [dbo].[SubjectAreaFormHistory] (
    [SubjectAreaFormId] INT           NOT NULL,
    [FormJson]          VARCHAR (MAX) NULL,
    [FormStatus]        TINYINT       NULL,
    [UpdatedBy]         VARCHAR (255) NULL,
    [ValidFrom]         DATETIME2 (0) NOT NULL,
    [ValidTo]           DATETIME2 (0) NOT NULL
);


GO
PRINT N'Creating [dbo].[SubjectAreaRoleMap]...';


GO
CREATE TABLE [dbo].[SubjectAreaRoleMap] (
    [SubjectAreaId]       INT                                         NOT NULL,
    [AadGroupUid]         UNIQUEIDENTIFIER                            NOT NULL,
    [ApplicationRoleName] VARCHAR (255)                               NOT NULL,
    [ExpiryDate]          DATE                                        NOT NULL,
    [ActiveYN]            BIT                                         NOT NULL,
    [UpdatedBy]           VARCHAR (255)                               NULL,
    [ValidFrom]           DATETIME2 (0) GENERATED ALWAYS AS ROW START NOT NULL,
    [ValidTo]             DATETIME2 (0) GENERATED ALWAYS AS ROW END   NOT NULL,
    PRIMARY KEY CLUSTERED ([SubjectAreaId] ASC, [AadGroupUid] ASC, [ApplicationRoleName] ASC),
    PERIOD FOR SYSTEM_TIME ([ValidFrom], [ValidTo])
)
WITH (SYSTEM_VERSIONING = ON (HISTORY_TABLE=[dbo].[SubjectAreaRoleMapHistory], DATA_CONSISTENCY_CHECK=ON));


GO
PRINT N'Creating [dbo].[SubjectAreaSystemMap]...';


GO
CREATE TABLE [dbo].[SubjectAreaSystemMap] (
    [SubjectAreaId]       INT                                         NOT NULL,
    [SystemId]            BIGINT                                      NOT NULL,
    [MappingType]         TINYINT                                     NOT NULL,
    [AllowedSchemas]      VARCHAR (MAX)                               NOT NULL,
    [ActiveYN]            BIT                                         NULL,
    [SubjectAreaFormId]   INT                                         NULL,
    [DefaultTargetSchema] VARCHAR (255)                               NULL,
    [UpdatedBy]           VARCHAR (255)                               NULL,
    [ValidFrom]           DATETIME2 (0) GENERATED ALWAYS AS ROW START NOT NULL,
    [ValidTo]             DATETIME2 (0) GENERATED ALWAYS AS ROW END   NOT NULL,
    PRIMARY KEY CLUSTERED ([SubjectAreaId] ASC, [SystemId] ASC, [MappingType] ASC),
    PERIOD FOR SYSTEM_TIME ([ValidFrom], [ValidTo])
)
WITH (SYSTEM_VERSIONING = ON (HISTORY_TABLE=[dbo].[SubjectAreaSystemMapHistory], DATA_CONSISTENCY_CHECK=ON));


GO
PRINT N'Creating [dbo].[SubjectAreaForm]...';


GO
CREATE TABLE [dbo].[SubjectAreaForm] (
    [SubjectAreaFormId] INT                                         IDENTITY (1, 1) NOT NULL,
    [FormJson]          VARCHAR (MAX)                               NULL,
    [FormStatus]        TINYINT                                     NULL,
    [UpdatedBy]         VARCHAR (255)                               NULL,
    [ValidFrom]         DATETIME2 (0) GENERATED ALWAYS AS ROW START NOT NULL,
    [ValidTo]           DATETIME2 (0) GENERATED ALWAYS AS ROW END   NOT NULL,
    PRIMARY KEY CLUSTERED ([SubjectAreaFormId] ASC),
    PERIOD FOR SYSTEM_TIME ([ValidFrom], [ValidTo])
)
WITH (SYSTEM_VERSIONING = ON (HISTORY_TABLE=[dbo].[SubjectAreaFormHistory], DATA_CONSISTENCY_CHECK=ON));


GO
PRINT N'Creating [dbo].[DF__TaskInsta__Numbe__32767D0B]...';


GO
ALTER TABLE [dbo].[TaskInstance]
    ADD CONSTRAINT [DF__TaskInsta__Numbe__32767D0B] DEFAULT ((0)) FOR [NumberOfRetries];


GO
PRINT N'Creating [dbo].[DF__TaskInsta__Creat__3FD07829]...';


GO
ALTER TABLE [dbo].[TaskInstance]
    ADD CONSTRAINT [DF__TaskInsta__Creat__3FD07829] DEFAULT (getutcdate()) FOR [CreatedOn];


GO
PRINT N'Creating [dbo].[DF_TaskInstance_UpdatedOn]...';


GO
ALTER TABLE [dbo].[TaskInstance]
    ADD CONSTRAINT [DF_TaskInstance_UpdatedOn] DEFAULT (getutcdate()) FOR [UpdatedOn];


GO
PRINT N'Creating [dbo].[DF__TaskMaste__Degre__43A1090D]...';


GO
ALTER TABLE [dbo].[TaskMaster]
    ADD CONSTRAINT [DF__TaskMaste__Degre__43A1090D] DEFAULT ((1)) FOR [DegreeOfCopyParallelism];


GO
PRINT N'Creating [dbo].[DF__TaskMaste__Allow__42ACE4D4]...';


GO
ALTER TABLE [dbo].[TaskMaster]
    ADD CONSTRAINT [DF__TaskMaste__Allow__42ACE4D4] DEFAULT ((0)) FOR [AllowMultipleActiveInstances];


GO
PRINT N'Creating [dbo].[DF_TaskGroup_MaximumTaskRetries]...';


GO
ALTER TABLE [dbo].[TaskGroup]
    ADD CONSTRAINT [DF_TaskGroup_MaximumTaskRetries] DEFAULT ((3)) FOR [MaximumTaskRetries];


GO
PRINT N'Creating [dbo].[DF_ExecutionEngine_EngineJson]...';


GO
ALTER TABLE [dbo].[ExecutionEngine]
    ADD CONSTRAINT [DF_ExecutionEngine_EngineJson] DEFAULT ('{}') FOR [EngineJson];


GO
PRINT N'Creating [pbi].[TaskInstanceAndScheduleInstance]...';


GO
/*-----------------------------------------------------------------------

 Copyright (c) Microsoft Corporation.
 Licensed under the MIT license.

-----------------------------------------------------------------------*/
create view pbi.TaskInstanceAndScheduleInstance as 
Select a.*, b.ScheduledDateUtc, b.ScheduledDateTimeOffset from dbo.TaskInstance a join dbo.ScheduleInstance b on a.ScheduleInstanceId = b.ScheduleInstanceId
GO
PRINT N'Creating [pbi].[ADFPipelineRun]...';


GO
/*-----------------------------------------------------------------------

 Copyright (c) Microsoft Corporation.
 Licensed under the MIT license.

-----------------------------------------------------------------------*/

create view pbi.ADFPipelineRun as 
select
	b.TaskInstanceId, 
	b.ExecutionUid, 
	b.DatafactoryId, 
	b.PipelineRunUid, 
	b.[Start], 
	b.[End],
	b.PipelineRunStatus,
	b.MaxPipelineTimeGenerated,		
	a.Activities						   ,
	a.TotalCost							   ,
	a.CloudOrchestrationCost			   ,
	a.SelfHostedOrchestrationCost		   ,
	a.SelfHostedDataMovementCost		   ,
	a.SelfHostedPipelineActivityCost	   ,
	a.CloudPipelineActivityCost			   ,
	a.rowsCopied						   ,
	a.dataRead							   ,
	a.dataWritten						   ,
	a.TaskExecutionStatus				   ,
	a.FailedActivities					   ,
	a.MaxActivityTimeGenerated
from dbo.ADFActivityRun a
join dbo.ADFPipelineRun b on a.PipelineRunUid = b.PipelineRunUid
GO
PRINT N'Creating [WebApp].[TaskGroupStats]...';


GO
create view WebApp.TaskGroupStats as
Select 
	tg.TaskGroupId,
	tg.TaskGroupName, 
	count(distinct tm.TaskMasterId) Tasks,
	count(distinct ti.TaskInstanceId) TaskInstances,
	count(distinct sm.ScheduleMasterId) Schedules,
	count(distinct si.ScheduleInstanceId) ScheduleInstances,
	count(distinct cast(tei.ExecutionUid as varchar(200))+cast(tei.TaskInstanceId as varchar(200))) Executions,
	sum(aps.TotalCost) EstimatedCost,
	sum(aps.rowsCopied) RowsCopied,
	sum(aps.DataRead) DataRead,
	sum(aps.DataWritten) DataWritten
from 	
	TaskGroup tg
	left join TaskMaster tm on tm.TaskGroupId = tg.TaskGroupId
	left join TaskInstance ti on ti.TaskMasterId = tm.TaskMasterId
	left join ScheduleInstance si on si.ScheduleInstanceId = ti.ScheduleInstanceId
	left join ScheduleMaster sm on sm.ScheduleMasterId = tm.ScheduleMasterId
	left join TaskInstanceExecution tei on tei.TaskInstanceId = ti.TaskInstanceId 
	left join ADFPipelineStats aps on aps.TaskInstanceId = ti.TaskInstanceId
group by Tg.TaskGroupId, Tg.TaskGroupName
GO
PRINT N'Creating [WebApp].[TaskMasterStats]...';


GO

create view [WebApp].[TaskMasterStats] as
Select 
	tg.TaskGroupId,
	tg.TaskGroupName, 
	tm.TaskMasterId, 
	tm.TaskMasterName, 
	count(distinct tm.TaskMasterId) Tasks,
	count(distinct ti.TaskInstanceId) TaskInstances,
	count(distinct sm.ScheduleMasterId) Schedules,
	count(distinct si.ScheduleInstanceId) ScheduleInstances,
	count(distinct cast(tei.ExecutionUid as varchar(200))+cast(tei.TaskInstanceId as varchar(200))) Executions,
	sum(aps.TotalCost) EstimatedCost,
	sum(aps.rowsCopied) RowsCopied,
	sum(aps.DataRead) DataRead,
	sum(aps.DataWritten) DataWritten
from 	
	TaskGroup tg
	join TaskMaster tm on tm.TaskGroupId = tg.TaskGroupId
	left join TaskInstance ti on ti.TaskMasterId = tm.TaskMasterId
	left join ScheduleInstance si on si.ScheduleInstanceId = ti.ScheduleInstanceId
	left join ScheduleMaster sm on sm.ScheduleMasterId = tm.ScheduleMasterId
	left join TaskInstanceExecution tei on tei.TaskInstanceId = ti.TaskInstanceId 
	left join ADFPipelineStats aps on aps.TaskInstanceId = ti.TaskInstanceId
group by 
	Tg.TaskGroupId, 
	Tg.TaskGroupName,
	tm.TaskMasterId, 
	tm.TaskMasterName
GO
PRINT N'Creating [Pbi].[ADFPipelineStats]...';


GO
/*-----------------------------------------------------------------------

 Copyright (c) Microsoft Corporation.
 Licensed under the MIT license.

-----------------------------------------------------------------------*/
create view Pbi.ADFPipelineStats as
select a.ExecutionUid, a.TaskInstanceId, a.PipelineRunStatus,  b.* 
from ADFPipelineRun a 
left join ADFActivityRun b on a.DatafactoryId = b.DataFactoryId and a.PipelineRunUid = b.PipelineRunUid
GO
PRINT N'Creating [dbo].[GetAzureStorageListingTriggeredTasksToBeSuppressed]...';


GO
/*-----------------------------------------------------------------------

 Copyright (c) Microsoft Corporation.
 Licensed under the MIT license.

-----------------------------------------------------------------------*/
create function [dbo].[GetAzureStorageListingTriggeredTasksToBeSuppressed] () returns table as
return
Select 
	distinct a.TaskInstanceId
from dbo.TaskInstance a
inner join dbo.TaskMaster b on a.TaskMasterId = b.TaskMasterId
inner join dbo.SourceAndTargetSystems s1 on s1.SystemId = b.SourceSystemId
cross apply
(Select TaskInstanceFilePathAndName = case when  ISJSON(a.TaskInstanceJson) = 1 and ISJSON(b.TaskMasterJSON) = 1 and  ISJSON(s1.SystemJSON)=1  then  JSON_Value(s1.SystemJSON,'$.Container')  + '/' + JSON_Value(a.TaskInstanceJson,'$.SourceRelativePath') + JSON_Value(b.TaskMasterJSON,'$.Source.DataFileName') else null end) c1
left join dbo.AzureStorageListing c on c1.TaskInstanceFilePathAndName = c.FilePath
where 
	a.LastExecutionStatus in ('Untried', 'FailedRetry') and a.TaskRunnerId is null
	and s1.SystemType in ('Azure Blob', 'ADLS')
	and ISJSON(a.TaskInstanceJson) = 1 and ISJSON(b.TaskMasterJSON) = 1 
	and a.ActiveYN = 1 and b.ActiveYN = 1
	and JSON_Value(b.TaskMasterJSON,'$.Source.TriggerUsingAzureStorageCache') = 'true'
	and c.FilePath is null
GO
PRINT N'Creating [dbo].[GetTasksToBeAssignedToRunners]...';


GO
/*-----------------------------------------------------------------------

 Copyright (c) Microsoft Corporation.
 Licensed under the MIT license.

-----------------------------------------------------------------------*/



--Select * from dbo.[GetTasksToBeAssignedToRunners]()
CREATE Function [dbo].[GetTasksToBeAssignedToRunners]() returns Table  
AS
RETURN
With AllTasksToBeRun as
(
SELECT 	
	TG.TaskGroupPriority, TG.TaskGroupId, TI.TaskInstanceId, SI.ScheduledDateTimeOffset
FROM 
[dbo].[TaskInstance] TI 
INNER JOIN [dbo].[ScheduleInstance] SI ON TI.ScheduleInstanceId = SI.ScheduleInstanceId
INNER JOIN [dbo].[TaskMaster] TM ON TI.TaskMasterID = TM.TaskMasterID
INNER JOIN [dbo].[TaskGroup] TG ON TM.TaskGroupId = TG.TaskGroupId
INNER JOIN [dbo].[SourceAndTargetSystems] SS ON SS.SystemId = TM.[SourceSystemId]
INNER JOIN [dbo].[SourceAndTargetSystems] TS ON TS.SystemId = TM.TargetSystemId
WHERE TI.ActiveYN = 1 and TI.LastExecutionStatus in ('Untried', 'FailedRetry') and TaskRunnerId is null
), 
TasksWithAnscestors as 
(
Select  TIP.TaskInstanceId, count(TGD.AncestorTaskGroupId) AscestorsNotReady 
from 			
	AllTasksTobeRun TIP
	INNER JOIN [dbo].[TaskInstance] TIDesc on TIP.TaskInstanceId = TIDesc.TaskInstanceId
	inner join [dbo].[TaskMaster] TMDesc on TIDesc.TaskMasterId = TMDesc.TaskMasterId
	Inner Join [dbo].[TaskGroup] TGDesc on TGDesc.TaskGroupId = TMDesc.TaskGroupId	
	Inner Join [dbo].[TaskGroupDependency] TGD on TGD.DescendantTaskGroupId = TMDesc.TaskGroupId 
	Inner Join [dbo].[TaskGroup] TGAnc on TGAnc.TaskGroupId = TGD.AncestorTaskGroupId  
	inner join [dbo].[TaskMaster] TMAnc on TMAnc.TaskGroupId = TGAnc.TaskGroupId and (TGD.DependencyType = 'EntireGroup' or TMAnc.DependencyChainTag = TMDesc.DependencyChainTag)
	inner join [dbo].[TaskInstance] TIAnc on TIAnc.TaskMasterId = TMAnc.TaskMasterId 
Where TIAnc.LastExecutionStatus in ('Untried', 'FailedRetry', 'InProgress') 
Group by TIP.TaskInstanceId
HAVING Count(*) > 0
union all
Select TaskInstanceId, 1 
from [GetAzureStorageListingTriggeredTasksToBeSuppressed]()
),
Result as 
(Select a.*
from AllTasksTobeRun a
left outer join
TasksWithAnscestors b on a.TaskInstanceId = b.TaskInstanceId
where b.TaskInstanceId is null
)
Select  *, IntraGroupExecutionOrder = ROW_NUMBER() over (Partition by TaskGroupid Order by ScheduledDateTimeOffset) 
from Result
GO
PRINT N'Creating [dbo].[GetTasksAssignedToRunners]...';


GO
/*-----------------------------------------------------------------------

 Copyright (c) Microsoft Corporation.
 Licensed under the MIT license.

-----------------------------------------------------------------------*/
/*-----------------------------------------------------------------------

 Copyright (c) Microsoft Corporation.
 Licensed under the MIT license.

-----------------------------------------------------------------------*/
--select * from [dbo].[GetTasksAssignedToRunners](null, 1)
CREATE Function [dbo].[GetTasksAssignedToRunners](@TaskRunnerId int = null, @IncludeInProgress bit) returns Table  
AS
RETURN
Select  b.TaskGroupId, TaskInstanceId
from [dbo].[TaskInstance] a
inner join TaskMaster b on a.TaskMasterId = b.TaskMasterId
where 
	(
		(@TaskRunnerId is null and a.TaskRunnerId is not null) 
		or 
		(@TaskRunnerId = a.TaskRunnerId)
	)
	and 
	(
		(LastExecutionStatus in ('Untried','FailedRetry') and @IncludeInProgress = 0)
		or 
		(LastExecutionStatus in ('Untried','FailedRetry', 'InProgress') and @IncludeInProgress = 1)
	)
GO
PRINT N'Creating [WebApp].[GetTaskStats]...';


GO
--select * from [WebApp].[GetTaskStats](2, null, 2, null)
CREATE function [WebApp].[GetTaskStats](@GroupByLevel tinyint, @TaskGroupId BigInt = null, @TaskMasterId BigInt = null, @TaskInstanceId BigInt = null) returns table as
return
(
Select 
	c1.TaskGroupId,
	c1.TaskGroupName,
	c1.TaskMasterId,
	c1.TaskMasterName,
	c1.TaskInstanceId,
	c1.ScheduledDateTime ,
	count(distinct tm.TaskMasterId) Tasks,
	count(distinct ti.TaskInstanceId) TaskInstances,
	count(distinct sm.ScheduleMasterId) Schedules,
	count(distinct si.ScheduleInstanceId) ScheduleInstances,
	count(distinct cast(tei.ExecutionUid as varchar(200))+cast(tei.TaskInstanceId as varchar(200))) Executions,
	sum(aps.TotalCost) EstimatedCost,
	sum(aps.rowsCopied) RowsCopied,
	sum(aps.DataRead) DataRead,
	sum(aps.DataWritten) DataWritten
from 	
	TaskGroup tg
	left join TaskMaster tm on tm.TaskGroupId = tg.TaskGroupId
	left join TaskInstance ti on ti.TaskMasterId = tm.TaskMasterId
	left join ScheduleInstance si on si.ScheduleInstanceId = ti.ScheduleInstanceId
	left join ScheduleMaster sm on sm.ScheduleMasterId = tm.ScheduleMasterId
	left join TaskInstanceExecution tei on tei.TaskInstanceId = ti.TaskInstanceId 
	left join ADFPipelineStats aps on aps.TaskInstanceId = ti.TaskInstanceId
cross apply 
(
Select 
	TaskGroupId = case when @GroupByLevel >= 0 then tg.TaskGroupId else null end,
	TaskGroupName = case when @GroupByLevel >= 0 then tg.TaskGroupName else null end,
	TaskMasterId = case when @GroupByLevel >= 1 then tm.TaskMasterId else null end,
	TaskMasterName = case when @GroupByLevel >= 1 then tm.TaskMasterName else null end, 
	TaskInstanceId = case when @GroupByLevel >= 2 then ti.TaskInstanceId else null end,
	ScheduledDateTime = case when @GroupByLevel >= 2 then si.ScheduledDateTimeOffset else null end
) c1
where tg.TaskGroupId = isnull(@TaskGroupId,tg.TaskGroupId)
group by 
	c1.TaskGroupId,
	c1.TaskGroupName,
	c1.TaskMasterId,
	c1.TaskMasterName,
	c1.TaskInstanceId,
	c1.ScheduledDateTime 
)
GO
PRINT N'Creating [dbo].[InsertActivityAudit]...';


GO
/*-----------------------------------------------------------------------

 Copyright (c) Microsoft Corporation.
 Licensed under the MIT license.

-----------------------------------------------------------------------*/

CREATE PROCEDURE [dbo].[InsertActivityAudit]
	@ActivityAuditId bigint
	,@ExecutionUid uniqueidentifier
	,@TaskInstanceId bigint
	,@AdfRunUid uniqueidentifier
	,@LogTypeId int
	,@LogSource nvarchar(50)
	,@ActivityType nvarchar(200)
	,@FileCount bigint
	,@LogDateUTC date
	,@LogDateTimeOffSet datetimeoffset(7)
	,@StartDateTimeOffSet datetimeoffset(7)
	,@EndDateTimeOffSet datetimeoffset(7)
	,@RowsInserted bigint
	,@RowsUpdated bigint
	,@Status nvarchar(50)
	,@Comment nvarchar(4000)

AS

	INSERT INTO [dbo].[ActivityAudit]
           (ActivityAuditId
           ,[ExecutionUid]
           ,[TaskInstanceId]
           ,[AdfRunUid]
           ,[LogTypeId]
           ,[LogSource]
           ,[ActivityType]
           ,[FileCount]
           ,[LogDateUTC]
           ,[LogDateTimeOffSet]
           ,[StartDateTimeOffSet]
           ,[EndDateTimeOffSet]
           ,[RowsInserted]
           ,[RowsUpdated]
           ,[Status]
           ,[Comment])
     VALUES
           (@ActivityAuditId 
           ,@ExecutionUid 
           ,@TaskInstanceId 
           ,@AdfRunUid 
           ,@LogTypeId 
           ,@LogSource 
           ,@ActivityType 
           ,@FileCount 
           ,@LogDateUTC 
           ,@LogDateTimeOffSet 
           ,@StartDateTimeOffSet 
           ,@EndDateTimeOffSet 
           ,@RowsInserted 
		   ,@RowsUpdated 
		   ,@Status 
           ,@Comment)
GO
PRINT N'Creating [dbo].[GetTaskGroups]...';


GO
/*-----------------------------------------------------------------------

 Copyright (c) Microsoft Corporation.
 Licensed under the MIT license.

-----------------------------------------------------------------------*/


CREATE procedure [dbo].[GetTaskGroups]
as
BEGIN
With 
NewTasks as 
(
	Select TaskGroupId, NewTasks = Count(distinct TaskInstanceId), 0 as TasksAssigned
	from [dbo].[GetTasksToBeAssignedToRunners]()
	Group by TaskGroupId, TaskGroupPriority
), 
AssignedTasks as 
(
	Select TaskGroupId, 0 NewTasks, count(TaskInstanceId) TasksAssigned
	from 
	[dbo].[GetTasksAssignedToRunners](null,1)
	group by TaskGroupId
), 
NewAndAssigned as 
(
	Select TaskGroupId, sum(NewTasks) NewTasks, sum(TasksAssigned) TasksAssigned 
	from 
	(
	Select TaskGroupId, NewTasks, 0 TasksAssigned from NewTasks 	
	union all 
	Select TaskGroupId, 0 NewTasks, TasksAssigned from AssignedTasks 	
	) a	
	Group by TaskGroupId
) 

Select	TG.*,  
		NewTasks TaskCount--,  
		--TasksAssigned, 
		--ConcurrencySlotsAvailableInGroup = TaskGroupConcurrency - TasksAssigned,
		--PercOfMaxConcurrencyConsumed = cast(TasksAssigned as numeric(18,4))/cast(TaskGroupConcurrency as numeric(18,4))
from TaskGroup TG
inner join NewAndAssigned NA on NA.TaskGroupId = TG.TaskGroupId
where NewTasks > 0
order by cast(TasksAssigned as numeric(18,4))/cast(TaskGroupConcurrency as numeric(18,4)) 
END
GO
PRINT N'Creating [dbo].[GetTaskInstanceJSON]...';


GO
/*-----------------------------------------------------------------------

 Copyright (c) Microsoft Corporation.
 Licensed under the MIT license.

-----------------------------------------------------------------------*/


--[dbo].[GetTaskInstanceJSON] 2,1000

CREATE proc [dbo].[GetTaskInstanceJSON] (@TaskRunnerId int, @ExecutionUid uniqueidentifier )
as
BEGIN 

--TODO - Wrap in transaction
Declare @TasksInProgress as table (TaskInstanceId bigint)

Update [dbo].[TaskInstance]
Set LastExecutionStatus='InProgress', 
	LastExecutionUid = @ExecutionUid, 
	LastExecutionComment = 'Task Picked Up For Execution by Runner ' + cast(@TaskRunnerId as varchar(20)),
	UpdatedOn = GETUTCDATE()
OUTPUT inserted.TaskInstanceId
INTO @TasksInProgress
from [dbo].[TaskInstance] a
inner join 
[dbo].[GetTasksAssignedToRunners](@TaskRunnerId, 0) b on a.TaskInstanceId = b.TaskInstanceId


SELECT 	
	TI.TaskInstanceId,
	TI.ADFPipeline,
	TI.NumberOfRetries,
	TI.TaskInstanceJson,
	SI.ScheduleMasterId, 
	TI.LastExecutionStatus as TaskStatus,
	tt.TaskTypeId as TaskTypeId,
	tt.TaskTypeName as TaskType,
	tt.TaskExecutionType,
	DF.DefaultKeyVaultURL as KeyVaultBaseUrl,
	DF.Id as DataFactoryId,
	DF.Name as DataFactoryName,
	DF.ResourceGroup as DataFactoryResourceGroup,
	DF.SubscriptionUid as DataFactorySubscriptionId,
	TM.TaskMasterJSON,
	TM.TaskMasterId,
	TM.DegreeOfCopyParallelism,
	TG.TaskGroupConcurrency,
	TG.TaskGroupPriority,
	TM.TaskDatafactoryIR,

	--SOURCE
	SS.SystemId as SourceSystemId,
	SS.SystemJSON as SourceSystemJSON,
	SS.SystemType as SourceSystemType,
	SS.SystemServer as SourceSystemServer,
	SS.SystemKeyVaultBaseUrl as SourceKeyVaultBaseUrl,
	SS.SystemAuthType as SourceSystemAuthType,
	SS.SystemSecretName as SourceSystemSecretName,
	SS.SystemUserName as SourceSystemUserName,
	
	--TARGET
	TS.SystemId as TargetSystemId,
	TS.SystemJSON as TargetSystemJSON,
	TS.SystemType as TargetSystemType,
	TS.SystemServer as TargetSystemServer,
	TS.SystemKeyVaultBaseUrl as TargetKeyVaultBaseUrl,
	TS.SystemAuthType as TargetSystemAuthType,
	TS.SystemSecretName as TargetSystemSecretName,
	TS.SystemUserName as TargetSystemUserName


FROM 
@TasksInProgress TIP
INNER JOIN [dbo].[TaskInstance] TI on TIP.TaskInstanceId = TI.TaskInstanceId
INNER JOIN [dbo].[ScheduleInstance] SI ON TI.ScheduleInstanceId = SI.ScheduleInstanceId
INNER JOIN [dbo].[TaskMaster] TM ON TI.TaskMasterID = TM.TaskMasterID
	--AND TM.ActiveYN = 1
INNER JOIN [dbo].[TaskType] tt on tt.TaskTypeId = TM.TaskTypeId
INNER JOIN [dbo].[TaskGroup] TG ON TM.TaskGroupId = TG.TaskGroupId
	--AND TG.ActiveYN = 1
INNER JOIN [dbo].[SourceAndTargetSystems] SS ON SS.SystemId = TM.[SourceSystemId]
	--AND SS.ActiveYN = 1
INNER JOIN [dbo].[SourceAndTargetSystems] TS ON TS.SystemId = TM.TargetSystemId
	--AND TS.ActiveYN = 1
INNER JOIN [dbo].[DataFactory] DF on DF.Id = TM.DataFactoryId



END
GO
PRINT N'Creating [dbo].[GetTaskMaster]...';


GO
/*-----------------------------------------------------------------------

 Copyright (c) Microsoft Corporation.
 Licensed under the MIT license.

-----------------------------------------------------------------------*/







Create proc [dbo].[GetTaskMaster]
as

Select 
	SM.ScheduleMasterId, 

	TM.TaskMasterJSON,
	TM.TaskMasterId,
	TM.TaskDatafactoryIR,
	TM.TaskTypeId,
	TT.[TaskExecutionType],

	--SOURCE
	SS.SystemJSON as SourceSystemJSON,
	SS.SystemType as SourceSystemType,
	
	--TARGET
	TS.SystemJSON as TargetSystemJSON,
	TS.SystemType as TargetSystemType

INTO #AllTasksTobeCreated

From
	[dbo].[ScheduleMaster] SM 

	Inner Join [dbo].[TaskMaster] TM
	ON TM.ScheduleMasterId = SM.ScheduleMasterId
	and TM.ActiveYN = 1	

	INNER Join [dbo].[TaskType] TT
	ON TT.TaskTypeId = TM.TaskTypeId

	Inner Join [dbo].[TaskGroup] TG
	ON TG.TaskGroupId = TM.TaskGroupId
	AND TG.ActiveYN = 1

	left Join [dbo].[TaskInstance] TI
	ON TI.TaskMasterId = TM.TaskMasterId
	AND TI.LastExecutionStatus in ('Untried','FailedRetry','InProgress')

	Inner Join [dbo].[SourceAndTargetSystems] SS
	ON SS.SystemId = TM.[SourceSystemId]
	and SS.ActiveYN = 1
	
	Inner Join [dbo].[SourceAndTargetSystems] TS
	ON TS.SystemId = TM.TargetSystemId
	and TS.ActiveYN = 1

Where SM.ActiveYN = 1
AND (
		(TM.AllowMultipleActiveInstances = 0 and TI.TaskMasterId is null)
		OR
		(TM.AllowMultipleActiveInstances = 1)
	)


--List of Task to be excluded due to incomplete dependencies (PARENT)
Select  TMAnc.TaskMasterId
into #TasksToBeExcludedParent
from 			
	[dbo].[TaskInstance] TI
	
	inner join [dbo].[TaskMaster] TM
	on TI.TaskMasterId = TM.TaskMasterId

	Inner Join [dbo].[TaskGroup] TG 
	on TG.TaskGroupId = TM.TaskGroupId	

	Inner Join [dbo].[TaskGroupDependency] TGD 
	on TGD.DescendantTaskGroupId = TM.TaskGroupId 
	and TGD.DependencyType = 'TasksMatchedByTagAndSchedule'

	Inner Join [dbo].[TaskGroup] TGAnc 
	on TGAnc.TaskGroupId = TGD.AncestorTaskGroupId  
	
	inner join [dbo].[TaskMaster] TMAnc
	on TMAnc.TaskGroupId = TGAnc.TaskGroupId 
	and TMAnc.DependencyChainTag = TM.DependencyChainTag
	
Where TI.LastExecutionStatus in ('Untried', 'FailedRetry', 'InProgress') 
AND TM.DependencyChainTag is not null

--List of Task to be excluded due to incomplete dependencies (CHILD)
Select  TM.TaskMasterId
into #TasksToBeExcludedCHILD
from 			
	[dbo].[TaskInstance] TI
	
	inner join [dbo].[TaskMaster] TM
	on TI.TaskMasterId = TM.TaskMasterId

	Inner Join [dbo].[TaskGroup] TG 
	on TG.TaskGroupId = TM.TaskGroupId	

	Inner Join [dbo].[TaskGroupDependency] TGD 
	on TGD.DescendantTaskGroupId = TM.TaskGroupId 
	and TGD.DependencyType = 'TasksMatchedByTagAndSchedule'

	Inner Join [dbo].[TaskGroup] TGAnc 
	on TGAnc.TaskGroupId = TGD.AncestorTaskGroupId  
	
	inner join [dbo].[TaskMaster] TMAnc
	on TMAnc.TaskGroupId = TGAnc.TaskGroupId 
	and TMAnc.DependencyChainTag = TM.DependencyChainTag
	
Where TI.LastExecutionStatus in ('Untried', 'FailedRetry', 'InProgress') 
AND TMAnc.DependencyChainTag is not null

--Delete Tasks from temp table that have incomplete dependencies 
Delete #AllTasksTobeCreated
from #AllTasksTobeCreated a
inner join #TasksToBeExcludedParent b
on a.TaskMasterId = b.TaskMasterId

Delete #AllTasksTobeCreated
from #AllTasksTobeCreated a
inner join #TasksToBeExcludedChild b
on a.TaskMasterId = b.TaskMasterId

select 
TaskMaster.*
,WaterMark.[TaskMasterWaterMarkColumn]
,WaterMark.[TaskMasterWaterMarkColumnType]
,WaterMark.[TaskMasterWaterMark_DateTime]
,WaterMark.[TaskMasterWaterMark_BigInt]
from #AllTasksTobeCreated AS TaskMaster
Left Join [dbo].[TaskMasterWaterMark] as WaterMark
On WaterMark.[TaskMasterId] = TaskMaster.[TaskMasterId]
and WaterMark.[ActiveYN] = 1
GO
PRINT N'Creating [dbo].[UpdFrameworkTaskRunner]...';


GO
/*-----------------------------------------------------------------------

 Copyright (c) Microsoft Corporation.
 Licensed under the MIT license.

-----------------------------------------------------------------------*/
Create procedure [dbo].[UpdFrameworkTaskRunner] (@TaskRunnerId as int) as 
Update FrameworkTaskRunner
Set Status = 'Idle', LastExecutionEndDateTime = GETUTCDATE()
GO
PRINT N'Creating [dbo].[UpdTaskInstanceExecution]...';


GO
/*-----------------------------------------------------------------------

 Copyright (c) Microsoft Corporation.
 Licensed under the MIT license.

-----------------------------------------------------------------------*/
CREATE procedure [dbo].[UpdTaskInstanceExecution] (@ExecutionStatus varchar(200), @TaskInstanceId bigint, @ExecutionUid uniqueidentifier, @AdfRunUid uniqueidentifier = null, @Comment varchar(255) = '')
as
Begin 

	Update [dbo].[TaskInstance] 
	SET LastExecutionStatus = c0.LastExecutionStatus, 		
		TaskRunnerId = Null, 
		LastExecutionComment = @Comment,
		UpdatedOn = GETUTCDATE(), 
		NumberOfRetries = c1.NumberOfRetries
	from [dbo].[TaskInstance] ti 
	join TaskMaster tm on tm.TaskMasterId = ti.TaskMasterId
	join TaskGroup tg on tg.TaskGroupId = tm.TaskGroupId
	cross apply 
	(
		Select
		LastExecutionStatus = 
			case 
				when @ExecutionStatus like 'Failed%' and ti.NumberOfRetries <  (tg.MaximumTaskRetries-1) then 'FailedRetry' 
				when @ExecutionStatus  like 'Failed%' and ti.NumberOfRetries >=  (tg.MaximumTaskRetries-1) then 'FailedNoRetry' 
				when @ExecutionStatus  = 'FailedNoRetry' then 'FailedNoRetry' 
				else @ExecutionStatus end
	) c0
	cross apply 
	(
		Select
		NumberOfRetries = case when @ExecutionStatus like 'Failed%' then (ti.NumberOfRetries + 1) else ti.NumberOfRetries end 
	) c1
	Where ti.TaskInstanceId = @TaskInstanceId                    
	
	--If the schedule is RunOnceOnly then Set Task to Inactive once complete or FailedNoRetry
	UPDATE dbo.TaskMaster 
		SET ActiveYN = 0
	FROM dbo.TaskMaster TM
	INNER JOIN  dbo.TaskInstance  TI
	ON TM.TaskMasterId = TI.TaskMasterId
	INNER JOIN dbo.ScheduleMaster SM
	ON SM.ScheduleMasterId = TM.ScheduleMasterId
	AND SM.ScheduleDesciption = 'Run Once Only'
	WHERE TI.TaskInstanceId = @TaskInstanceId
	and @ExecutionStatus in ('Complete', 'FailedNoRetry')

	UPDATE [dbo].[TaskInstanceExecution]
	SET [Status] = @ExecutionStatus, 
		EndDateTime = GetDate(), 
		AdfRunUid = @AdfRunUid
	Where TaskInstanceId = @TaskInstanceId and ExecutionUid = @ExecutionUid




END
GO
PRINT N'Creating [dbo].[GetFrameworkTaskRunners]...';


GO
/*-----------------------------------------------------------------------

 Copyright (c) Microsoft Corporation.
 Licensed under the MIT license.

-----------------------------------------------------------------------*/
CREATE procedure [dbo].[GetFrameworkTaskRunners] as 

declare @Output as Table (TaskRunnerId int)

Update FrameworkTaskRunner
Set Status = 'Running', LastExecutionStartDateTime = GETUTCDATE()
OUTPUT inserted.TaskRunnerId into @Output (TaskRunnerId)
where ActiveYN = 1 and Status = 'Idle'

Select FTR.* from FrameworkTaskRunner FTR inner join @Output O on O.TaskRunnerId = FTR.TaskRunnerId
GO
PRINT N'Creating [dbo].[usp_StagingTable_Load]...';


GO
/*-----------------------------------------------------------------------

 Copyright (c) Microsoft Corporation.
 Licensed under the MIT license.

-----------------------------------------------------------------------*/
/*
EXECUTE [ETL].[usp_StagingTable_Load] '{"TargetTable": "TaskMaster"}','dbo'

*/


CREATE PROCEDURE dbo.[usp_StagingTable_Load]
(
	@TaskConfig VARCHAR(MAX)
	,@TaskSchema VARCHAR(MAX)
)

AS


BEGIN TRY

	BEGIN TRANSACTION

	DECLARE 
		@SchemaDrift CHAR(1)
		,@TargetTable VARCHAR(100)
		,@HistoryTargetTable VARCHAR(110)
		,@TargetTempTable VARCHAR(100)
		,@LoadType VARCHAR(50)
		,@AlterSQL NVARCHAR(MAX) = ''
		,@DeleteSQL NVARCHAR(MAX) = ''
		,@UpdateSQL NVARCHAR(MAX) = ''
		,@InsertSQL NVARCHAR(MAX) = ''
		,@InsertSQLMain NVARCHAR(MAX) = ''
		,@InsertSQLWhere NVARCHAR(MAX) = ''
		,@AlterHistorySQL NVARCHAR(MAX) = ''
		,@SourceFileFormat VARCHAR(50)
		,@ErrorMessage VARCHAR(500)
		,@TaskInstanceID VARCHAR(50)
		,@AutoSchemaDetection CHAR(1)
		,@IncludeSQLDataLineage CHAR(1)
		,@HistoryTable VARCHAR(50)
		,@UseSQLCDC VARCHAR(50)
		,@TargetCDCTempTable VARCHAR(255)


	-- Get TaskConfig Target connection stage variables
	SELECT 
		@SchemaDrift = JSON_VALUE(TaskConfig.[value], '$.AllowSchemaDrift')
		,@TargetTable = JSON_VALUE(TaskConfig.[value], '$.TargetTable')
		,@HistoryTargetTable = CONCAT(LEFT(@TargetTable, LEN(@TargetTable) - 1 ), '_history]')
		,@TargetTempTable = JSON_VALUE(TaskConfig.[value], '$.TargetTempTable')
		,@LoadType = JSON_VALUE(TaskConfig.[value], '$.LoadType')
		,@TaskInstanceID = JSON_VALUE(TaskConfig.[value], '$.TaskInstanceID')
		,@IncludeSQLDataLineage = JSON_VALUE(TaskConfig.[value], '$.IncludeSQLDataLineage')
		,@HistoryTable = JSON_VALUE(TaskConfig.[value], '$.HistoryTable')
	FROM 
		OPENJSON(@TaskConfig) TaskConfig
	WHERE
		JSON_VALUE(TaskConfig.[value], '$.ConnectionStage') = 'Target'

	-- Get CDC temp table 
	SET @TargetCDCTempTable = PARSENAME(@TargetTempTable,2) + '.' + PARSENAME(@TargetTempTable,1) + '_cdc'
	
	-- Get TaskConfig Source connection stage variables
	SELECT 
		@SourceFileFormat = JSON_VALUE(TaskConfig.[value], '$.SourceFileFormat') -- Check if we are doing a file load
		,@AutoSchemaDetection = JSON_VALUE(TaskConfig.[value], '$.AutoSchemaDetection') -- Check if we have auto schema detection from the source
		,@UseSQLCDC = JSON_VALUE(TaskConfig.[value], '$.UseSQLCDC')
	FROM 
		OPENJSON(@TaskConfig) TaskConfig
	WHERE
		JSON_VALUE(TaskConfig.[value], '$.ConnectionStage') = 'Source'

	--Throw a custom error if we don't have any column level metadata for the table
	IF ISNULL(@TaskSchema, '') = ''
    BEGIN
		SET @ErrorMessage = 'No column metadata available for table ' + @TargetTable + '. Please check source database permissions'
        		
		-- Raise the error
		RAISERROR (@ErrorMessage, 16, 1);     
    END

	-- Get the source and target schemas
	DROP TABLE IF EXISTS #TargetSchema 

	SELECT 
		ISNULL(TargetTable.OriginalColumnName, TempTable.OriginalColumnName) AS OriginalColumnName
	   ,ISNULL(TargetTable.TargetColumnName, TempTable.TempColumnName) AS TargetColumnName
	   ,CASE
			WHEN TargetTable.OriginalColumnName IS NULL	AND TempTable.TempColumnName <> 'ETL_Operation'
			THEN 'Add'
			WHEN TempTable.OriginalColumnName IS NULL AND NOT(@IncludeSQLDataLineage = 'Y' AND TargetTable.OriginalColumnName LIKE 'ADS!_%' ESCAPE '!')
			THEN 'Delete'
			WHEN ISNULL(TempTable.TempColumnName, '') <> 'ETL_Operation'
			THEN 'Update'
		END AS ColumnAction
	   ,TempTable.TempColumnName
	   ,TempTable.NewColumnName
	   ,TempTable.TargetDataType
	   ,TargetTable.KeyColumn
	   ,TargetTable.AllowNull
	INTO
		#TargetSchema
	FROM 
		(
		SELECT
			Col.OriginalColumnName
			,C.COLUMN_NAME AS TargetColumnName
			,CASE
				WHEN IC.IndexColumnName IS NOT NULL 
				THEN 'Y'
				ELSE 'N'
			END AS KeyColumn
			,CASE C.IS_NULLABLE
				WHEN 'YES'
				THEN 'Y'
				WHEN 'NO'
				THEN 'N'
			END AS AllowNull
		FROM
			INFORMATION_SCHEMA.[COLUMNS] C
			CROSS APPLY OPENJSON(@TaskSchema) TaskSchema
			CROSS APPLY
			(
			SELECT
				JSON_VALUE(TaskSchema.[value], '$.OriginalColumnName') AS OriginalColumnName
				,JSON_VALUE(TaskSchema.[value], '$.TransformedColumnName') AS TransformedColumnName
			) Col
			LEFT OUTER JOIN 
			(
			SELECT
				SCHEMA_NAME(T.[schema_id]) AS TABLE_SCHEMA
				,T.[name] AS TABLE_NAME
				,C.[name] AS IndexColumnName
			FROM
				sys.tables T
				INNER JOIN sys.indexes I ON T.[object_id] = I.[object_id]
				INNER JOIN sys.index_columns IC ON I.[object_id] = IC.[object_id]
					AND I.index_id = IC.index_id
				INNER JOIN sys.[columns] C ON T.[object_id] = C.[object_id]
					AND IC.column_id = C.column_id
			WHERE
				I.is_unique = 1
			) IC ON C.TABLE_SCHEMA = IC.TABLE_SCHEMA
				AND C.TABLE_NAME = IC.TABLE_NAME
				AND C.COLUMN_NAME = IC.IndexColumnName
		WHERE
	 		C.TABLE_SCHEMA = PARSENAME(@TargetTable, 2)
			AND C.TABLE_NAME = PARSENAME(@TargetTable, 1)
			AND C.COLUMN_NAME = Col.OriginalColumnName

		UNION ALL

		--Get the ADS data lineage columns
		SELECT
			C.COLUMN_NAME AS OriginalColumnName
			,C.COLUMN_NAME AS TargetColumnName
			,'N' AS KeyColumn
			,CASE C.IS_NULLABLE
				WHEN 'YES'
				THEN 'Y'
				WHEN 'NO'
				THEN 'N'
			END AS AllowNull
		FROM
			INFORMATION_SCHEMA.[COLUMNS] C
		WHERE
	 		C.TABLE_SCHEMA = PARSENAME(@TargetTable, 2)
			AND C.TABLE_NAME = PARSENAME(@TargetTable, 1)
			AND C.COLUMN_NAME LIKE 'ADS!_%' ESCAPE '!'
		) TargetTable
		FULL OUTER JOIN
		(
		SELECT
			Col.OriginalColumnName
			,C.COLUMN_NAME AS TempColumnName
			,JSON_VALUE(TaskSchema.[value], '$.SQLDataType') AS TargetDataType
			,CASE
				WHEN @AutoSchemaDetection = 'Y'
				THEN Col.OriginalColumnName
				ELSE Col.TransformedColumnName
			END AS NewColumnName
		FROM
			INFORMATION_SCHEMA.[COLUMNS] C
			CROSS APPLY OPENJSON(@TaskSchema) TaskSchema
			CROSS APPLY
			(
			SELECT
				JSON_VALUE(TaskSchema.[value], '$.OriginalColumnName') AS OriginalColumnName
				,JSON_VALUE(TaskSchema.[value], '$.TransformedColumnName') AS TransformedColumnName
			) Col
		WHERE
	 		C.TABLE_SCHEMA = PARSENAME(@TargetTempTable, 2)
			AND C.TABLE_NAME = PARSENAME(@TargetTempTable, 1)
			AND C.COLUMN_NAME = Col.TransformedColumnName

		UNION ALL

		-- Get the ETL_Operation Column
		SELECT
			C.COLUMN_NAME AS OriginalColumnName
			,C.COLUMN_NAME AS TempColumnName
			,'' AS TargetDataType
			,'' AS NewColumnName
		FROM
			INFORMATION_SCHEMA.[COLUMNS] C
		WHERE
	 		C.TABLE_SCHEMA = PARSENAME(@TargetTempTable, 2)
			AND C.TABLE_NAME = PARSENAME(@TargetTempTable, 1)
			AND C.COLUMN_NAME = 'ETL_Operation'
		) TempTable ON TargetTable.OriginalColumnName = TempTable.OriginalColumnName

	IF @HistoryTable = 'True' 

	BEGIN 
		-- Create HistoryTargetSchema table
		DROP TABLE IF EXISTS #HistoryTargetSchema

		SELECT 
			ISNULL(HistoryTargetTable.OriginalColumnName, HistoryTempTable.OriginalColumnName) AS OriginalColumnName
		   ,ISNULL(HistoryTargetTable.TargetColumnName, HistoryTempTable.TempColumnName) AS TargetColumnName
		   ,CASE
				WHEN HistoryTargetTable.OriginalColumnName IS NULL	AND HistoryTempTable.TempColumnName <> 'ETL_Operation'
				THEN 'Add'
				WHEN HistoryTempTable.OriginalColumnName IS NULL AND NOT(HistoryTargetTable.OriginalColumnName LIKE 'ADS!_%' ESCAPE '!' OR HistoryTargetTable.OriginalColumnName LIKE '__$%')
				THEN 'Delete'
				ELSE 'Update'
			END AS ColumnAction
		   ,ISNULL(HistoryTargetTable.TempColumnName, HistoryTempTable.TempColumnName) AS TempColumnName
		   ,HistoryTempTable.NewColumnName
		   ,ISNULL(HistoryTargetTable.TargetDataType, HistoryTempTable.TargetDataType) AS TargetDataType 
		   ,HistoryTargetTable.KeyColumn
		   ,HistoryTargetTable.AllowNull
		INTO
			#HistoryTargetSchema
		FROM 
			(
			SELECT
				Col.OriginalColumnName
				,C.COLUMN_NAME AS TargetColumnName
				,NULL AS TempColumnName
				,NULL AS TargetDataType
				,CASE
					WHEN IC.IndexColumnName IS NOT NULL 
					THEN 'Y'
					ELSE 'N'
				END AS KeyColumn
				,CASE C.IS_NULLABLE
					WHEN 'YES'
					THEN 'Y'
					WHEN 'NO'
					THEN 'N'
				END AS AllowNull
			FROM
				INFORMATION_SCHEMA.[COLUMNS] C
				CROSS APPLY OPENJSON(@TaskSchema) TaskSchema
				CROSS APPLY
				(
				SELECT
					JSON_VALUE(TaskSchema.[value], '$.OriginalColumnName') AS OriginalColumnName
					,JSON_VALUE(TaskSchema.[value], '$.TransformedColumnName') AS TransformedColumnName
				) Col
				LEFT OUTER JOIN 
				(
				SELECT
					SCHEMA_NAME(T.[schema_id]) AS TABLE_SCHEMA
					,T.[name] AS TABLE_NAME
					,C.[name] AS IndexColumnName
				FROM
					sys.tables T
					INNER JOIN sys.indexes I ON T.[object_id] = I.[object_id]
					INNER JOIN sys.index_columns IC ON I.[object_id] = IC.[object_id]
						AND I.index_id = IC.index_id
					INNER JOIN sys.[columns] C ON T.[object_id] = C.[object_id]
						AND IC.column_id = C.column_id
				WHERE
					I.is_unique = 1
				) IC ON C.TABLE_SCHEMA = IC.TABLE_SCHEMA
					AND C.TABLE_NAME = IC.TABLE_NAME
					AND C.COLUMN_NAME = IC.IndexColumnName
			WHERE
	 			C.TABLE_SCHEMA = PARSENAME(@HistoryTargetTable, 2)
				AND C.TABLE_NAME = PARSENAME(@HistoryTargetTable, 1)
				AND C.COLUMN_NAME = Col.OriginalColumnName

			UNION ALL

			--Get the ADS data lineage columns
			SELECT
				C.COLUMN_NAME AS OriginalColumnName
				,C.COLUMN_NAME AS TargetColumnName
				,NULL AS TempColumnName
				,NULL AS TargetDataType
				,'N' AS KeyColumn
				,CASE C.IS_NULLABLE
					WHEN 'YES'
					THEN 'Y'
					WHEN 'NO'
					THEN 'N'
				END AS AllowNull
			FROM
				INFORMATION_SCHEMA.[COLUMNS] C
			WHERE
	 			C.TABLE_SCHEMA = PARSENAME(@HistoryTargetTable, 2)
				AND C.TABLE_NAME = PARSENAME(@HistoryTargetTable, 1)
				AND C.COLUMN_NAME LIKE 'ADS!_%' ESCAPE '!'

			UNION ALL

			--Get the CDC columns
			SELECT
				C.COLUMN_NAME AS OriginalColumnName
				,C.COLUMN_NAME AS TargetColumnName
				,C.COLUMN_NAME AS TempColumnName
				,CASE WHEN C.CHARACTER_MAXIMUM_LENGTH IS NOT NULL THEN C.DATA_TYPE + '(' + CASE WHEN C.CHARACTER_MAXIMUM_LENGTH = -1 THEN 'max' ELSE CAST(C.CHARACTER_MAXIMUM_LENGTH AS VARCHAR(MAX)) END + ')' WHEN C.DATA_TYPE = 'datetimeoffset' THEN  C.DATA_TYPE + '(' + CAST(C.DATETIME_PRECISION AS VARCHAR(MAX))  + ')'  ELSE  C.DATA_TYPE END AS TargetDataType
				,'N' AS KeyColumn
				,CASE C.IS_NULLABLE
					WHEN 'YES'
					THEN 'Y'
					WHEN 'NO'
					THEN 'N'
				END AS AllowNull
			FROM
				INFORMATION_SCHEMA.[COLUMNS] C
			WHERE
	 			C.TABLE_SCHEMA = PARSENAME(@HistoryTargetTable, 2)
				AND C.TABLE_NAME = PARSENAME(@HistoryTargetTable, 1)
				AND C.COLUMN_NAME LIKE '__$%'
			) HistoryTargetTable
			FULL OUTER JOIN
			(
			SELECT
				Col.OriginalColumnName
				,C.COLUMN_NAME AS TempColumnName
				,JSON_VALUE(TaskSchema.[value], '$.SQLDataType') AS TargetDataType
				,CASE
					WHEN @AutoSchemaDetection = 'Y'
					THEN Col.OriginalColumnName
					ELSE Col.TransformedColumnName
				END AS NewColumnName
			FROM
				INFORMATION_SCHEMA.[COLUMNS] C
				CROSS APPLY OPENJSON(@TaskSchema) TaskSchema
				CROSS APPLY
				(
				SELECT
					JSON_VALUE(TaskSchema.[value], '$.OriginalColumnName') AS OriginalColumnName
					,JSON_VALUE(TaskSchema.[value], '$.TransformedColumnName') AS TransformedColumnName
				) Col
			WHERE
	 			C.TABLE_SCHEMA = PARSENAME(CASE WHEN @UseSQLCDC = 'True' THEN @TargetCDCTempTable ELSE @TargetTempTable END, 2)
				AND C.TABLE_NAME = PARSENAME(CASE WHEN @UseSQLCDC = 'True' THEN @TargetCDCTempTable ELSE @TargetTempTable END, 1)
				AND C.COLUMN_NAME = Col.TransformedColumnName

			UNION ALL

			-- Get the ETL_Operation Column
			SELECT
				C.COLUMN_NAME AS OriginalColumnName
				,C.COLUMN_NAME AS TempColumnName
				,'varchar(255)' AS TargetDataType
				,'' AS NewColumnName
			FROM
				INFORMATION_SCHEMA.[COLUMNS] C
			WHERE
	 			C.TABLE_SCHEMA = PARSENAME(CASE WHEN @UseSQLCDC = 'True' THEN @TargetCDCTempTable ELSE @TargetTempTable END, 2)
				AND C.TABLE_NAME = PARSENAME(CASE WHEN @UseSQLCDC = 'True' THEN @TargetCDCTempTable ELSE @TargetTempTable END, 1)
				AND C.COLUMN_NAME = 'ETL_Operation'
			) HistoryTempTable ON HistoryTargetTable.OriginalColumnName = HistoryTempTable.OriginalColumnName

			
			
	END
	--PRINT @UseSQLCDC 
	--PRINT @TargetCDCTempTable
	--SELECT * FROM #HistoryTargetSchema
	--RETURN 

	-- Fail the ETL if schema drift is not allowed and schema has changed

	IF @SchemaDrift = 'N'

	BEGIN

		IF EXISTS (SELECT 1 FROM #TargetSchema TS WHERE TS.ColumnAction = 'Add') 
        BEGIN

			SELECT 
				@ErrorMessage = 'Schema drift not allowed and column/s added/renamed in ' + @TargetTable + ': ' + STRING_AGG(TS.NewColumnName, ',')
			FROM 
				#TargetSchema TS 
			WHERE 
				TS.ColumnAction = 'Add'
        		
			-- Raise the error
			
			RAISERROR (@ErrorMessage, 16, 1); 
        
        END

	END

	-- If schema drift is allowed, add any missing columns to the target table
	
	ELSE IF @SchemaDrift = 'Y'

	BEGIN

		SELECT
			@AlterSQL = 'ALTER TABLE ' + @TargetTable + ' ADD ' + STRING_AGG('[' + TS.NewColumnName + '] ' + TS.TargetDataType, ',') + ';'
		FROM 
			#TargetSchema TS 
		WHERE 
			TS.ColumnAction = 'Add'

		--EXEC sys.sp_executesql @AlterSQL
		Print @AlterSQL
		IF @HistoryTable = 'True'

		BEGIN 

			SELECT
				@AlterHistorySQL = 'ALTER TABLE ' + @HistoryTargetTable + ' ADD ' + STRING_AGG('[' + TS.NewColumnName + '] ' + TS.TargetDataType, ',') + ';'
			FROM 
				#HistoryTargetSchema TS 
			WHERE 
				TS.ColumnAction = 'Add'

			--EXEC sys.sp_executesql @AlterHistorySQL
			PRINT @AlterHistorySQL
		END 

	END

	-- If data lineage is enabled and the columns don't exist, then add them
	IF @IncludeSQLDataLineage = 'Y' AND NOT EXISTS(SELECT 1 FROM #TargetSchema TS WHERE TS.OriginalColumnName LIKE 'ADS!_%' ESCAPE '!')

	BEGIN

		SELECT
			@AlterSQL = 'ALTER TABLE ' + @TargetTable + ' ADD [ADS_DateCreated] DATETIMEOFFSET,[ADS_TaskInstanceID] INT'

		--EXEC sys.sp_executesql @AlterSQL
		PRINT @AlterSQL
		-- Insert the column metadata into the #TargetSchema table

		INSERT INTO #TargetSchema
		(
			OriginalColumnName
			,TargetColumnName
			,ColumnAction
			,TempColumnName
			,TargetDataType
			,KeyColumn
			,AllowNull
		)
		SELECT
			'ADS_DateCreated'
			,'ADS_DateCreated'
			,'Update'
			,NULL
			,'DATETIMEOFFSET'
			,'N'
			,'Y'
		UNION ALL
		SELECT
			'ADS_TaskInstanceID'
			,'ADS_TaskInstanceID'
			,'Update'
			,NULL
			,'INT'
			,'N'
			,'Y'

	END

	-- Load the data

	-- Generate the SQL insert statement

	DECLARE
		@ETLColumnExists BIT = ISNULL((SELECT 1 FROM #TargetSchema TS WHERE TS.TempColumnName = 'ETL_Operation'), 0)

	IF @AutoSchemaDetection = 'N'

	BEGIN

		-- Do type casts for manual schema specification

		SELECT
			@InsertSQLMain = 'INSERT INTO ' + CAST(@TargetTable AS NVARCHAR(MAX)) + '(' + STRING_AGG('[' + CAST(TS.TargetColumnName AS NVARCHAR(MAX)) + ']', ',') + 
			') SELECT ' + STRING_AGG( +	CASE
											WHEN @IncludeSQLDataLineage = 'Y' AND TS.TargetColumnName = 'ADS_DateCreated'
											THEN 'SYSUTCDATETIME()'
											WHEN @IncludeSQLDataLineage = 'Y' AND TS.TargetColumnName = 'ADS_TaskInstanceID'
											THEN @TaskInstanceID
											WHEN TS.TargetDataType LIKE '%date%'
											THEN 'TRY_CAST([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] AS ' + CAST(TS.TargetDataType AS NVARCHAR(MAX)) + ')'
											--Added to remove scientific notation issues
											WHEN TS.TargetDataType LIKE '%decimal%' OR TS.TargetDataType LIKE '%numeric%'
											THEN 'CASE WHEN TRY_CAST([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] AS ' + CAST(TS.TargetDataType AS NVARCHAR(MAX)) + ') IS NULL AND [' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] IS NOT NULL THEN CAST(CAST([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] AS FLOAT) AS ' + CAST(TS.TargetDataType AS NVARCHAR(MAX)) + ') ELSE [' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] END'
											WHEN TS.TargetDataType = 'geography'
											THEN 'geography::STGeomFromText([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '], 4326)'
											WHEN TS.TargetDataType = 'geometry'
											THEN 'geometry::STGeomFromText([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '], 4326)'
											WHEN TS.TargetDataType ='hierarchyid'
											THEN 'TRY_CAST([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] AS ' + CAST(TS.TargetDataType AS NVARCHAR(MAX)) + ')'
											WHEN TS.TargetDataType NOT LIKE '%char%'
											THEN 'TRY_CAST([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] AS ' + CAST(TS.TargetDataType AS NVARCHAR(MAX)) + ')'
											ELSE '[' + TS.TempColumnName + ']'
										END , ',') + ' FROM ' + CAST(@TargetTempTable AS NVARCHAR(MAX)) + CASE WHEN @ETLColumnExists = 1 THEN ' WHERE [ETL_Operation] <> ''Delete''' ELSE '' END
		FROM
			#TargetSchema TS
		WHERE
			TS.ColumnAction IN('Update','Add')

	END

	ELSE

	BEGIN

		SELECT
			@InsertSQLMain = 'INSERT INTO ' + CAST(@TargetTable AS NVARCHAR(MAX)) + '(' + STRING_AGG('[' + CAST(TargetCol.TargetColumnName AS NVARCHAR(MAX)) + ']', ',')  +							
			') SELECT ' + STRING_AGG( +	CASE
											WHEN @IncludeSQLDataLineage = 'Y' AND TargetCol.TargetColumnName = 'ADS_DateCreated'
											THEN 'SYSUTCDATETIME()'
											WHEN @IncludeSQLDataLineage = 'Y' AND TargetCol.TargetColumnName = 'ADS_TaskInstanceID'
											THEN @TaskInstanceID
											WHEN TS.TargetDataType LIKE '%date%'
											THEN 'TRY_CAST([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] AS ' + CAST(TS.TargetDataType AS NVARCHAR(MAX)) + ')'
											--Added to remove scientific notation issues
											WHEN TS.TargetDataType LIKE '%decimal%' OR TS.TargetDataType LIKE '%numeric%'
											THEN 'CASE WHEN TRY_CAST([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] AS ' + CAST(TS.TargetDataType AS NVARCHAR(MAX)) + ') IS NULL AND [' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] IS NOT NULL THEN CAST(CAST([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] AS FLOAT) AS ' + CAST(TS.TargetDataType AS NVARCHAR(MAX)) + ') ELSE [' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] END'
											WHEN TS.TargetDataType = 'geography'
											THEN 'geography::STGeomFromText([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '], 4326)'
											WHEN TS.TargetDataType = 'geometry'
											THEN 'geometry::STGeomFromText([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '], 4326)'
											WHEN TS.TargetDataType ='hierarchyid'
											THEN 'TRY_CAST([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] AS ' + CAST(TS.TargetDataType AS NVARCHAR(MAX)) + ')'
											ELSE '[' + TS.TempColumnName + ']'
										END , ',') + ' FROM ' + CAST(@TargetTempTable AS NVARCHAR(MAX)) + CASE WHEN @ETLColumnExists = 1 THEN ' WHERE [ETL_Operation] <> ''Delete''' ELSE '' END
		FROM
			#TargetSchema TS
			CROSS APPLY
			(
			SELECT
				CASE
					WHEN TS.ColumnAction = 'Add'
					THEN TS.NewColumnName
					ELSE TS.TargetColumnName
				END AS TargetColumnName
			) TargetCol
		WHERE
			TS.ColumnAction IN('Update','Add')

	END

	-- Add WHERE clause to exclude invalid dates where columns don't allow nulls

	IF EXISTS(SELECT 1 FROM #TargetSchema TS WHERE TS.AllowNull = 'N' AND TS.TargetDataType LIKE 'date%')

	BEGIN

		SELECT
			@InsertSQLWhere = CASE WHEN @ETLColumnExists = 1 THEN ' AND ' ELSE ' WHERE ' END + 
			STRING_AGG(
			CASE
				WHEN TS.TargetDataType LIKE 'date%'
				THEN 'TRY_CAST([' + TS.TempColumnName + '] AS ' + TS.TargetDataType + ') IS NOT NULL'
				ELSE ''
			END , ' AND ')
		FROM
			#TargetSchema TS
		WHERE
			TS.AllowNull = 'N'
			AND TS.TargetDataType LIKE 'date%'

	END

	SET @InsertSQL = @InsertSQLMain + @InsertSQLWhere

	-- Do a full load if there is no primary key or unique index or this is the first load for a table

	IF NOT EXISTS (SELECT 1 FROM #TargetSchema TS WHERE TS.KeyColumn = 'Y') 
		OR (NOT EXISTS (SELECT 1 FROM #TargetSchema TS WHERE TS.TempColumnName = 'ETL_Operation') AND @LoadType = 'Full')
    BEGIN
    
    	EXEC('TRUNCATE TABLE ' + @TargetTable)

		--EXEC sys.sp_executesql @InsertSQL
		PRINT @InsertSQL

    END

	ELSE

	-- There is a key and an ETL operation so do Insert, Update and Delete

	BEGIN

		-- Delete missing data

		SELECT
			@DeleteSQL = 'DELETE T FROM ' + @TargetTempTable + ' S INNER JOIN ' + @TargetTable + ' T ON ' + 
			STRING_AGG(
			CASE
				WHEN TS.AllowNull = 'Y'
				THEN
				CASE
					WHEN TS.TargetDataType IN('decimal', 'numeric')
					THEN 'COALESCE(S.[' + TS.TempColumnName + '], CAST(0 AS DECIMAL(36,12)) = COALESCE(T.[' + TS.TargetColumnName + '], CAST(0 AS DECIMAL(36,12))'
					WHEN TS.TargetDataType LIKE '%int%' OR TS.TargetDataType LIKE '%money%' OR TS.TargetDataType IN('real', 'float')
					THEN 'COALESCE(S.[' + TS.TempColumnName + '], 0) = COALESCE(T.[' + TS.TargetColumnName + '], 0)'
					WHEN TS.TargetDataType LIKE 'date%'
					THEN 'COALESCE(TRY_CAST(S.[' + TS.TempColumnName + '] AS ' + TS.TargetDataType + '), '''') = COALESCE(TRY_CAST(T.[' + TS.TargetColumnName + '] AS ' + TS.TargetDataType + '), '''')'
					ELSE 'COALESCE(S.[' + TS.TempColumnName + '], '''') = COALESCE(T.[' + TS.TargetColumnName + '], '''')'
				END
				ELSE 'S.[' + TS.TempColumnName + '] = T.[' + TS.TargetColumnName + ']'
			END, ' AND ')
		FROM
			#TargetSchema TS
		WHERE
			TS.KeyColumn = 'Y'

		-- Don't do updates as they are slow, rather do a delete and insert
		
		-- Remove changed data

		--EXEC sys.sp_executesql @DeleteSQL
		PRINT @DeleteSQL

		-- Insert new data

		--EXEC sys.sp_executesql @InsertSQL
		PRINT @InsertSQL

	END

	-- Insert to the history table if HistoryTable is enabled 
	IF @HistoryTable = 'True'  
	BEGIN 

		-- Generate history table insert sql statement 
		IF @AutoSchemaDetection = 'N'

		BEGIN

			-- Do type casts for manual schema specification
			
			SELECT
				@InsertSQLMain = 'INSERT INTO ' + CAST(@HistoryTargetTable AS NVARCHAR(MAX)) + '(' + STRING_AGG('[' + CAST(TS.TargetColumnName AS NVARCHAR(MAX)) + ']', ',') + 
				') SELECT ' + STRING_AGG( +	CASE
												WHEN TS.TargetColumnName = 'ADS_DateCreated'
												THEN 'SYSUTCDATETIME()'
												WHEN TS.TargetColumnName = 'ADS_TaskInstanceID'
												THEN @TaskInstanceID
												WHEN TS.TargetDataType LIKE '%date%'
												THEN 'TRY_CAST([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] AS ' + CAST(TS.TargetDataType AS NVARCHAR(MAX)) + ')'
												--Added to remove scientific notation issues
												WHEN TS.TargetDataType LIKE '%decimal%' OR TS.TargetDataType LIKE '%numeric%'
												THEN 'CASE WHEN TRY_CAST([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] AS ' + CAST(TS.TargetDataType AS NVARCHAR(MAX)) + ') IS NULL AND [' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] IS NOT NULL THEN CAST(CAST([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] AS FLOAT) AS ' + CAST(TS.TargetDataType AS NVARCHAR(MAX)) + ') ELSE [' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] END'
												WHEN TS.TargetDataType = 'geography'
												THEN 'geography::STGeomFromText([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '], 4326)'
												WHEN TS.TargetDataType = 'geometry'
												THEN 'geometry::STGeomFromText([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '], 4326)'
												WHEN TS.TargetDataType ='hierarchyid'
												THEN 'TRY_CAST([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] AS ' + CAST(TS.TargetDataType AS NVARCHAR(MAX)) + ')'
												WHEN TS.TargetDataType NOT LIKE '%char%'
												THEN 'TRY_CAST([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] AS ' + CAST(TS.TargetDataType AS NVARCHAR(MAX)) + ')'
												ELSE '[' + TS.TempColumnName + ']'
											END , ',') + ' FROM ' + CAST(CASE WHEN @UseSQLCDC = 'True' THEN @TargetCDCTempTable ELSE @TargetTempTable END  AS NVARCHAR(MAX))
			FROM
				#HistoryTargetSchema TS
			WHERE
				TS.ColumnAction IN('Update','Add')

		END

		ELSE

		BEGIN
			--SELECT * FROM #HistoryTargetSchema
			--RETURN 
			SELECT
				@InsertSQLMain = 'INSERT INTO ' + CAST(@HistoryTargetTable AS NVARCHAR(MAX)) + '(' + STRING_AGG('[' + CAST(TargetCol.TargetColumnName AS NVARCHAR(MAX)) + ']', ',') +
				') SELECT ' + STRING_AGG( +	CASE
												WHEN TargetCol.TargetColumnName = 'ADS_DateCreated'
												THEN 'SYSUTCDATETIME()'
												WHEN TargetCol.TargetColumnName = 'ADS_TaskInstanceID'
												THEN @TaskInstanceID
												WHEN TS.TargetDataType LIKE '%date%'
												THEN 'TRY_CAST([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] AS ' + CAST(TS.TargetDataType AS NVARCHAR(MAX)) + ')'
												--Added to remove scientific notation issues
												WHEN TS.TargetDataType LIKE '%decimal%' OR TS.TargetDataType LIKE '%numeric%'
												THEN 'CASE WHEN TRY_CAST([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] AS ' + CAST(TS.TargetDataType AS NVARCHAR(MAX)) + ') IS NULL AND [' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] IS NOT NULL THEN CAST(CAST([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] AS FLOAT) AS ' + CAST(TS.TargetDataType AS NVARCHAR(MAX)) + ') ELSE [' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] END'
												WHEN TS.TargetDataType = 'geography'
												THEN 'geography::STGeomFromText([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '], 4326)'
												WHEN TS.TargetDataType = 'geometry'
												THEN 'geometry::STGeomFromText([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '], 4326)'
												WHEN TS.TargetDataType ='hierarchyid'
												THEN 'TRY_CAST([' + CAST(TS.TempColumnName AS NVARCHAR(MAX)) + '] AS ' + CAST(TS.TargetDataType AS NVARCHAR(MAX)) + ')'
												ELSE '[' + TS.TempColumnName + ']'
											END , ',') + ' FROM ' + CAST(CASE WHEN @UseSQLCDC = 'True' THEN @TargetCDCTempTable ELSE @TargetTempTable END AS NVARCHAR(MAX))
			FROM
				#HistoryTargetSchema TS
				CROSS APPLY
				(
				SELECT
					CASE
						WHEN TS.ColumnAction = 'Add'
						THEN TS.NewColumnName
						ELSE TS.TargetColumnName
					END AS TargetColumnName
				) TargetCol
			WHERE
				TS.ColumnAction IN('Update','Add')
		END

		IF EXISTS(SELECT 1 FROM #HistoryTargetSchema TS WHERE TS.AllowNull = 'N' AND TS.TargetDataType LIKE 'date%')

		BEGIN

			SELECT
				@InsertSQLWhere = ' WHERE ' + 
				STRING_AGG(
				CASE
					WHEN TS.TargetDataType LIKE 'date%'
					THEN 'TRY_CAST([' + TS.TempColumnName + '] AS ' + TS.TargetDataType + ') IS NOT NULL'
					ELSE ''
				END , ' AND ')
			FROM
				#HistoryTargetSchema TS
			WHERE
				TS.AllowNull = 'N'
				AND TS.TargetDataType LIKE 'date%'

		END

		SET @InsertSQL = @InsertSQLMain + @InsertSQLWhere

		--PRINT @InsertSQL
		--RETURN

		-- Delete task instance Id that exist in history table 
		SET @DeleteSQL = 'DELETE FROM ' + @HistoryTargetTable + ' WHERE ADS_TaskInstanceID = ' + @TaskInstanceID
		--EXEC sys.sp_executesql @DeleteSQL
		PRINT @DeleteSQL
		-- Execute insert sql statement 
		--EXEC sys.sp_executesql @InsertSQL
		PRINT @InsertSQL

	END

	COMMIT TRANSACTION

END TRY

BEGIN CATCH

	ROLLBACK TRANSACTION

	DECLARE @Error VARCHAR(MAX)
	SET @Error = ERROR_MESSAGE()
	;
	THROW 51000, @Error, 1 
END CATCH
GO
-- Refactoring step to update target server with deployed transaction logs

IF OBJECT_ID(N'dbo.__RefactorLog') IS NULL
BEGIN
    CREATE TABLE [dbo].[__RefactorLog] (OperationKey UNIQUEIDENTIFIER NOT NULL PRIMARY KEY)
    EXEC sp_addextendedproperty N'microsoft_database_tools_support', N'refactoring log', N'schema', N'dbo', N'table', N'__RefactorLog'
END
GO
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '6076314c-821f-4594-98a8-186c526946b2')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('6076314c-821f-4594-98a8-186c526946b2')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'c94184fb-7030-4bd4-bf28-950dd778332f')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('c94184fb-7030-4bd4-bf28-950dd778332f')

GO

GO
DECLARE @VarDecimalSupported AS BIT;

SELECT @VarDecimalSupported = 0;

IF ((ServerProperty(N'EngineEdition') = 3)
    AND (((@@microsoftversion / power(2, 24) = 9)
          AND (@@microsoftversion & 0xffff >= 3024))
         OR ((@@microsoftversion / power(2, 24) = 10)
             AND (@@microsoftversion & 0xffff >= 1600))))
    SELECT @VarDecimalSupported = 1;

IF (@VarDecimalSupported > 0)
    BEGIN
        EXECUTE sp_db_vardecimal_storage_format N'$(DatabaseName)', 'ON';
    END


GO
PRINT N'Update complete.';


GO
